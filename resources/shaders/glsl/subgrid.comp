// Vulkan/GLSL compute shader
// author: Christian Suer (github: 'cyberchriz')

#version 450 core

#define MAX_UNIFORM_SIZE 10
#define MAX_DIMENSIONS 10


// setup specialization constants
// in "main" use gl_WorkGroupSize.x / gl_WorkGroupSize.y / gl_WorkGroupSize.z to get the actual workgroup size
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

// setup buffers
layout(set = 0, binding = 0) buffer data_buffer {float data[];};
layout(set = 0, binding = 1) uniform shape_buffer {uint shape[MAX_UNIFORM_SIZE];};
layout(set = 0, binding = 2) uniform subspace_buffer {uint subspace[MAX_UNIFORM_SIZE];};

layout(set = 0, binding = 3) buffer subgrid_buffer {float subgrid[];};
layout(set = 0, binding = 4) uniform subgrid_shape_buffer {uint subgrid_shape[MAX_UNIFORM_SIZE];};
layout(set = 0, binding = 5) uniform subgrid_subspace_buffer {uint subgrid_subspace[MAX_UNIFORM_SIZE];};

layout(set = 0, binding = 6) uniform source_offset_buffer {uint source_offset[MAX_UNIFORM_SIZE];};

// setup push constants layout
layout(push_constant) uniform push_constants {
    uint dimensions;
};

// setup global variables
uint array_index[MAX_DIMENSIONS];
uint subgrid_array_index[MAX_DIMENSIONS];

// Helper function to convert a flat index back to a multidimensional index
// note: as a simple scalar GLSL will pass the flat_index by value, so the passed variable remains unchanged;
// however, the result_array_index is passed by reference, so it will be modified (as intended)
void multi_index(uint flat_index, uint result_array_index[MAX_DIMENSIONS]) {
    for (uint i = 0; i < dimensions; ++i) {
        result_array_index[i] = flat_index / subspace[i];
        flat_index = flat_index % subspace[i];
    }
}

// main function
void main() {
    uint flat_index = gl_GlobalInvocationID.x;

    // convert flat index to multidimensional index
    multi_index(flat_index, array_index);

    // get corresponding multidimensional index of the subgrid
    bool out_of_bounds = false;
    for (uint i = 0; i < dimensions; ++i) {
        subgrid_array_index[i] = array_index[i] - source_offset[i];
        out_of_bounds = subgrid_array_index[i] < 0;
    }

    if (!out_of_bounds) {
        // convert multidimensional subgrid index back to flat index
        uint subgrid_flat_index = 0;
        for (uint i = 0; i < dimensions; ++i) {
            subgrid_flat_index += subgrid_array_index[i] * subgrid_subspace[i];
        }
        // write data to the subgrid
        subgrid[subgrid_flat_index] = data[flat_index];
    }
}
