// Vulkan/GLSL compute shader
// author: Christian Suer (github: 'cyberchriz')

#version 450 core

// default constants
#define MAX_UNIFORM_SIZE 10
#define MAX_DIMENSIONS 10

// setup specialization constants
// in "main" use gl_WorkGroupSize.x / gl_WorkGroupSize.y / gl_WorkGroupSize.z to get the actual workgroup size
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

// setup buffers
layout(set = 0, binding = 0) buffer data_buffer {float data[];};
layout(set = 0, binding = 1) uniform data_shape_buffer {uint data_shape[MAX_UNIFORM_SIZE];};
layout(set = 0, binding = 2) uniform data_subspace_buffer {uint data_subspace[MAX_UNIFORM_SIZE];};

// setup push constants layout
layout(push_constant) uniform push_constants {
    uint data_N;            // total number of elements in the source array
    uint data_dim;          // number of dimensions of the source array
};

// setup global variables
uint data_array_index[MAX_DIMENSIONS];

// Helper function to convert a multidimensional index of the data buffer to the corresponding flat index
uint flat_index(uint array_index[MAX_DIMENSIONS], const uint subspace[MAX_DIMENSIONS], const uint dimensions) {
    uint flat_index = 0;
    for (uint i = 0; i < dimensions; ++i) {
        flat_index += array_index[i] * subspace[i];
    }
    return flat_index;
}

// Helper function to convert a flat index back to a multidimensional index
// note: as a simple scalar GLSL will pass the flat_index by value, so the passed variable remains unchanged;
// however, the result_array_index is passed by reference, so it will be modified (as intended)
void multi_index(uint flat_index, uint result_array_index[MAX_DIMENSIONS], const uint subspace[MAX_DIMENSIONS], const uint dimensions) {
    for (uint i = 0; i < dimensions; ++i) {
        result_array_index[i] = flat_index / subspace[i];
        flat_index = flat_index % subspace[i];
    }
}

// Simple random float function based on seed
float random(uint seed) {
    uint state = seed;
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return float(state & 0xFFFFFFFF) / 4294967295.0;
}

// Marsaglia polar method for Gaussian normal distribution
float randomGaussian(uint seed, float mu, float sigma) {
    float v1, v2, s;
    do {
        v1 = 2.0f * random(seed) - 1.0f;
        v2 = 2.0f * random(seed+12345)  - 1.0f;
        s = v1 * v1 + v2 * v2;
    } while (s >= 1.0f || s == 0);
    s = sqrt((-2.0f * log(s)) / s);
    return v1 * s * sigma + mu;
}

// main function
void main() {
    uint flat_index = gl_GlobalInvocationID.x;
    
    // ... main code here ...

}
