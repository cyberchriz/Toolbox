// this Vulkan/GLSL compute shader counts any occurrence of the specified value
// and stores the result in an integer buffer with a single element

#version 450
#define WORKGROUP_SIZE 256

// setup buffers
layout(set = 0, binding = 0) buffer DataBuffer {
	float data[];
};
layout(set = 0, binding = 1) buffer ResultBuffer {
	float result[];
};
layout(set = 0, binding = 2) buffer SignalBuffer {
	uint signal[];
};

// setup push constants layout
layout(push_constant) uniform PushConstants {
	uint data_elements;
	float value;
};

// setup local size according to workgroup size
layout(local_size_x = WORKGROUP_SIZE) in;

// global variables
float epsilon = 0.0000001;

// main function
void main() {
	uint x = gl_GlobalInvocationID.x;
	uint workgroup_ID = x / WORKGROUP_SIZE;
	uint workgroups = data_elements / WORKGROUP_SIZE + 1;
	if (gl_LocalInvocationID.x == 0) {
		signal[workgroup_ID] = 0;
	}
	
	if (x < data_elements) {

		// check for match
		result[x] = abs(data[x] - value) <= epsilon ? 1 : 0;

		// add up partial results within workgroup via parallel reduction
		barrier();
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				result[x] += result[x+i];
			}
			barrier();
		}
		signal[workgroup_ID] = 1;

		// for final result: add partial results across workgroups
		if (x == 0) {
			for (uint i = 1; i < workgroups; i++) {
				uint loop_count = 0;
				while (signal[i] != 1 && loop_count < 10000) {
					memoryBarrier();
					loop_count++;
				}
				result[0] += result[i*WORKGROUP_SIZE];
			}
		}
	}
}