// this Vulkan/GLSL compute shader assigns any outliers
// beyond the given z-score to mean of all elements

#version 450
#define WORKGROUP_SIZE 256

// setup buffers
layout(set = 0, binding = 0) buffer DataBuffer {
	float data[];
};
layout(set = 0, binding = 1) buffer ResultBuffer {
	float result[];
};
layout(set = 0, binding = 2) buffer SignalBuffer {
	uint signal[];
};

// setup push constants layout
layout(push_constant) uniform PushConstants {
	uint data_elements;
	float z_score;
};

// setup local size according to workgroup size
layout(local_size_x = WORKGROUP_SIZE) in;

// main function
void main() {
	uint x = gl_GlobalInvocationID.x;
	uint workgroup_ID = x / WORKGROUP_SIZE;
	uint workgroups = data_elements / WORKGROUP_SIZE + 1;
	float sum;
	float mean;
	float variance;
	float sigma;
	float lower_margin;
	float upper_margin;

	if (gl_LocalInvocationID.x == 0) {
		signal[workgroup_ID] = 0;
	}
	
	if (x < data_elements) {

		// get local sum within workgroup via parallel reduction
		result[x] = data[x];
		barrier();
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				result[x] += result[x+i];
			}
			barrier();
		}
		signal[workgroup_ID] = 1;

		// get global sum across workgroups
		sum = result[0];
		for (uint i = 1; i < workgroups; i++) {
			uint loop_count = 0;
			while (signal[i] != 1 && loop_count < 10000) {
				memoryBarrier();
				loop_count++;
			}
			sum += result[i*WORKGROUP_SIZE];
		}
		barrier();

		// get mean
		mean = sum / data_elements;

		// get local sum of squared mean deviations within workgroup via parallel reduction
		float mdev = data[x] - mean;
		result[x] = mdev * mdev;
		barrier();
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				result[x] += result[x+i];
			}
			barrier();
		}
		signal[workgroup_ID] = 2;

		// get global sum of squared mean deviations across workgroups
		sum = result[0];
		for (uint i = 1; i < workgroups; i++) {
			uint loop_count = 0;
			while (signal[i] != 2 && loop_count < 10000) {
				memoryBarrier();
				loop_count++;
			}
			sum += result[i*WORKGROUP_SIZE];
		}
		barrier();

		// get variance and standard deviation
		variance = sum / data_elements;
		sigma = sqrt(variance);

		// get margins
		lower_margin = mean - z_score * sigma;
		upper_margin = mean + z_score * sigma;

		// reassign outliers
		float value = data[x];
		if (value > upper_margin || value < lower_margin) {
			result[x] = mean;
		}
		else {
			result[x] = value;
		}
	}
}