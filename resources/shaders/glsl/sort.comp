// Vulkan/GLSL compute shader
// author: Christian Suer (github: 'cyberchriz')

#version 450 core

// Setup specialization constants for workgroup size
// Example: layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

layout(set = 0, binding = 0) buffer data_buffer { float data[];};

// Push constants for sort parameters
layout(push_constant) uniform push_constants {
    uint N;                 // Actual number of elements in the buffer
    uint N_pow2;            // Smallest power of 2 >= N (calculated by host)
    uint ascending_order;   // 1 for ascending, 0 for descending
};

// --- Helper Function: Compare and Swap (with Boundary Checks against N) ---
// Compares elements at index i and j and swaps them if they are in the wrong order
// according to the desired direction 'dir'. Only proceeds if BOTH i and j are < N.
// 'dir' = true means ascending (data[i] should be <= data[j])
// 'dir' = false means descending (data[i] should be >= data[j])
void compare_and_swap(uint i, uint j, bool dir) {
    // --- Boundary Check ---
    // Ensure BOTH indices are within the valid data range [0, N-1]
    if (i >= N || j >= N) {
        return; // Do nothing
    }

    // Indices are valid, proceed with comparison and potential swap
    float val_i = data[i];
    float val_j = data[j];

    // Check if elements are in the desired order relative to each other
    // dir=true (ascending): swap if val_i > val_j
    // dir=false (descending): swap if val_i < val_j
    bool needs_swap = (val_i > val_j) == dir;

    if (needs_swap) {
        data[i] = val_j;
        data[j] = val_i;
    }
}

// --- Main Compute Shader Function ---
void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= N_pow2) { return; }
    bool ascending = bool(ascending_order);

    // Bitonic Sort Stages - looping up to N_pow2 defines the sorting network structure

    // Outer loop: controls the size of the blocks being merged/sorted (k)
    // k goes up to N_pow2
    for (uint k = 2; k <= N_pow2; k <<= 1) {
        // Inner loop: controls the comparison distance (j) within a block
        // This loop performs the bitonic merge steps for sequences of size k
        for (uint j = k >> 1; j > 0; j >>= 1) {

            // Determine the desired comparison direction for this thread based on its
            // position within the conceptual k-sized blocks of the N_pow2 grid.
            // This pattern ensures subsequences are sorted correctly to form larger bitonic sequences.
            bool direction = ((idx & k) == 0) == ascending;

            // Identify the pair of elements to compare and potentially swap using XOR
            uint partner_idx = idx ^ j;

            if (partner_idx > idx) {
                 compare_and_swap(idx, partner_idx, direction);
            }

            // --- Synchronization ---
            memoryBarrierBuffer();
            barrier();
        }
    }
}