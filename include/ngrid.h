// author and copyright: Christian Suer (cyberchriz)
// description: class for parallel floating point data structure computations on the GPU (using Vulkan)


#ifndef NGRID_H
#define NGRID_H
#pragma once // not strictly necessary if the included header files also all come with include guards, but just to be on the safe side

#define NOMINMAX
#include <angular.h>            // custom class for angular units
#include <log.h>                // custom logging class
#include <vkcontext.h>          // custom wrapper library for Vulkan context
#include <__msvc_ostream.hpp>
#include <cmath>
#include <cstdint>
#include <iostream>
#include <minwindef.h>
#include <stdlib.h>
#include <rnd.h>                // custom random number generator
#include <string>
#include <type_traits>
#include <vector>
#include <vulkan/vulkan.h>
#include <Windows.h>
#include <initializer_list>
#include <spirv_bin.h>          // source header for compute shader binaries (auto-generated by CMake + GLSL compiler (glslangValidator))


// list of available activation functions
enum ActFunc {
    RELU,       // rectified linear unit (ReLU)
    LRELU,      // leaky rectified linear unit (LReLU)
    ELU,        // exponential linar unit (ELU)
    LELU,       // leaky exponential linear unit
    SIGMOID,    // sigmoid (=logistic)
    TANH,       // hyperbolic tangent (tanh), with angular unit radians
    IDENT       // identity function
};


template <typename T>
class Example {
    // constructor
    Example(uint32_t first, Args... rest) {
		data = { first, rest... };
    }
private:
	std::vector<uint32_t> data;
    T variable = 0;
};

// data structure class for parallel computing with Vulkan
class NGrid {
public:
    // +=================================+   
    // | Constructors & Destructors      |
    // +=================================+
	NGrid(std::initializer_list<uint32_t> shape);   // parametric default constructor for multi-dimensional array
    NGrid(NGrid&& other) noexcept;                  // move constructor
    NGrid(const NGrid& other);                      // copy constructor
    ~NGrid();                                       // destructor

    // +=================================+   
    // | getters & setters               |
    // +=================================+
    void set(const float_t value, const uint32_t row_index, const uint32_t col_index = 0, const uint32_t layer_index = 0);
    void set(std::vector<float_t>& data);
    float_t get(const uint32_t row_index, const uint32_t col_index = 0, const uint32_t layer_index = 0) const;
    std::vector<float> get() const;
    Buffer<float_t>* get_data_buffer() const;
    uint32_t get_dimensions() const;
    uint32_t get_rows() const;
    uint32_t get_cols() const;
    uint32_t get_depth() const;
    uint32_t get_elements() const;
    std::string get_shapestring() const;
    NGrid get_row(int32_t row_index) const;
    NGrid get_col(int32_t col_index) const;
    NGrid get_layer(int32_t layer_index) const;

    // +=================================+   
    // | Fill, Initialize                |
    // +=================================+
    void fill(const float_t value);
    void fill_zero();
    void fill_identity();
    void fill_random_gaussian(const float_t mu = 0.0f, const float_t sigma = 1.0f);
    void fill_random_uniform(const float_t min = 0.0f, const float_t max = 1.0f);
    void fill_random_uniform_int(const int32_t min = 0, const int32_t max = 9);
    void fill_random_binary(float_t ratio = 0.5f);
    void fill_random_sign(float_t ratio = 0.5f);
    void fill_range(const float_t start = 0.0f, const float_t step = 1.0f);
    void fill_dropout(float_t ratio = 0.2f);
    void fill_Xavier_normal(uint32_t fan_in, uint32_t fan_out);
    void fill_Xavier_uniform(uint32_t fan_in, uint32_t fan_out);
    void fill_Xavier_sigmoid(uint32_t fan_in, uint32_t fan_out);
    void fill_He_ReLU(uint32_t fan_in);
    void fill_He_ELU(uint32_t fan_in);
    void fill_index();

    // +=================================+   
    // | Distribution Properties         |
    // +=================================+

    float_t min() const;
    float_t max() const;
    float_t maxabs() const;
    float_t mean() const;
    float_t median() const;
    float_t variance() const;
    float_t stddev() const;
    float_t kurtosis() const;
    float_t skewness() const;
    float_t norm() const;

    // +=================================+   
    // | Addition                        |
    // +=================================+

    // returns the sum of all array elements
    float_t sum() const;
    NGrid operator+(const float_t value) const;
    NGrid operator+(const NGrid& other) const;
    NGrid& operator++(); // prefix increment
    NGrid operator++(int); // postfix increment
    void operator+=(const float_t value);
    void operator+=(const NGrid& other);

    // +=================================+   
    // | Substraction                    |
    // +=================================+

    NGrid operator-(const float_t value) const;
    NGrid operator-(const NGrid& other) const;
    NGrid& operator--(); // prefix decrement
    NGrid operator--(int); // postfix decrement
    void operator-=(const float_t value);
    void operator-=(const NGrid& other);

    // +=================================+   
    // | Multiplication                  |
    // +=================================+

    float_t product() const;
    NGrid operator*(const float_t factor) const;
    void operator*=(const float_t factor);
    NGrid operator*(const NGrid& other) const; // alias for matrix product
    void operator*=(const NGrid& other); // "equals matrix product"
    float_t scalar_product(const NGrid& other) const;
    NGrid matrix_product(const NGrid& other) const;
    NGrid Hadamard_product(const NGrid& other) const;

    // +=================================+   
    // | Division                        |
    // +=================================+

    NGrid operator/(const float_t quotient) const;
    void operator/=(const float_t quotient);
    NGrid Hadamard_division(const NGrid& other);

    // +=================================+   
    // | Modulo                          |
    // +=================================+

    void operator%=(const float_t value);
    NGrid operator%(const float_t num) const;

    // +=================================+   
    // | Exponentiation & Logarithm      |
    // +=================================+

    NGrid pow(const float_t exponent = 2.0f) const;
    NGrid operator^(const float_t exponent) const;
    void operator^=(const float_t exponent);
    NGrid pow(const NGrid& other) const;
    NGrid operator^(const NGrid& other) const;
    NGrid sqrt() const;
    NGrid log(float_t base = 2.718282) const;
    NGrid exp() const;

    // +=================================+   
    // | Rounding                        |
    // +=================================+

    NGrid round() const;
    NGrid floor() const;
    NGrid ceil() const;
    NGrid abs() const;

    // +=================================+   
    // | Min, Max                        |
    // +=================================+

    NGrid min(const float_t value) const;
    NGrid max(const float_t value) const;
    NGrid min(const NGrid& other) const;
    NGrid max(const NGrid& other) const;

    // +=================================+   
    // | Trigonometric Functions         |
    // +=================================+

    NGrid cos(AngularMeasure unit = RAD) const;
    NGrid sin(AngularMeasure unit = RAD) const;
    NGrid tan(AngularMeasure unit = RAD) const;
    NGrid acos(AngularMeasure unit = RAD) const;
    NGrid asin(AngularMeasure unit = RAD) const;
    NGrid atan(AngularMeasure unit = RAD) const;
    NGrid cosh(AngularMeasure unit = RAD) const;
    NGrid sinh(AngularMeasure unit = RAD) const;
    NGrid tanh(AngularMeasure unit = RAD) const;
    NGrid acosh(AngularMeasure unit = RAD) const;
    NGrid asinh(AngularMeasure unit = RAD) const;
    NGrid atanh(AngularMeasure unit = RAD) const;

    // +=================================+   
    // | Find, Replace                   |
    // +=================================+

    NGrid replace(const float_t& old_value, const float_t& new_value) const;
    NGrid replace_if(const NGrid& condition_map, const NGrid& replacing_map) const;
    NGrid replace_if(const NGrid& condition_map, const float_t replacing_value) const;
    uint32_t find(const float_t& value) const;
    NGrid sign() const;

    // +=================================+   
    // | Scaling                         |
    // +=================================+
    
    NGrid scale_minmax(float_t range_from = 0.0f, float_t range_to = 1.0f) const;
    NGrid scale_mean() const;
    NGrid scale_standardized() const;

    // +=================================+   
    // | Activation Functions            |
    // | (with Derivatives)              |
    // +=================================+

    NGrid activation(ActFunc activation_function) const;
    NGrid derivative(ActFunc activation_function) const;

    NGrid ident() const;                                NGrid ident_drv() const;
    NGrid sigmoid() const;                              NGrid sigmoid_drv() const;
    NGrid elu(float_t alpha = 0.01) const;              NGrid elu_drv(float_t alpha = 0.01) const;
    NGrid relu(float_t alpha = 0.01) const;             NGrid relu_drv(float_t alpha = 0.01) const;
                                                        NGrid tanh_drv(AngularMeasure unit = RAD) const;

    // +=================================+   
    // | Outlier Treatment               |
    // +=================================+
    
    NGrid outliers_truncate(float_t z_score = 3.0f) const;
    NGrid outliers_truncate(const float_t min_value, const float_t max_value) const;
    NGrid outliers_mean_imputation(float_t z_score = 3.0f) const;
    NGrid outliers_value_imputation(float_t value = 0, float_t z_score = 3.0f) const;
    NGrid recover() const;

    // +=================================+   
    // | Assignment                      |
    // +=================================+

    NGrid& operator=(const NGrid& other); // copy assignment
    NGrid& operator=(NGrid&& other) noexcept; // move assignment

    // +=================================+   
    // | Elementwise Comparison          |
    // +=================================+

    NGrid operator>(const float_t value) const;
    NGrid operator>=(const float_t value) const;
    NGrid operator==(const float_t value) const;
    NGrid operator!=(const float_t value) const;
    NGrid operator<(const float_t value) const;
    NGrid operator<=(const float_t value) const;
    NGrid operator>(const NGrid& other) const;
    NGrid operator>=(const NGrid& other) const;
    NGrid operator==(const NGrid& other) const;
    NGrid operator!=(const NGrid& other) const;
    NGrid operator<(const NGrid& other) const;
    NGrid operator<=(const NGrid& other) const;

    // +=================================+   
    // | Elementwise Logial Operations   |
    // +=================================+

    NGrid operator&&(const bool value) const;
    NGrid operator||(const bool value) const;
    NGrid operator!() const;
    NGrid operator&&(const NGrid& other) const;
    NGrid operator||(const NGrid& other) const;

    // +=================================+   
    // | Dynamic Handling & Conversion   |
    // +=================================+

    float_t pop_first();
    float_t pop_last();
    NGrid flatten() const;
    NGrid erase_row(const uint32_t row_index);
    NGrid erase_col(const uint32_t col_index);
    NGrid erase_layer(const uint32_t depth_layer_index);
    NGrid add_rows(const int32_t rows = 1, float_t init_value = 0.0f) const;
    NGrid add_cols(const int32_t cols = 1, float_t init_value = 0.0f) const;
    NGrid add_depth(const int32_t layers = 1, float_t init_value = 0.0f) const;
    NGrid resize(const uint32_t rows, const uint32_t cols = 1, const uint32_t depth = 1, float_t init_value = 0.0f) const;
    NGrid concatenate(const NGrid& other, const uint32_t axis = 0) const;
    NGrid padding(const float_t value = 0.0f, const uint32_t before_rows = 1, const uint32_t after_rows = 1, const uint32_t before_cols = 0, const uint32_t after_cols = 0, const uint32_t above_layers = 0, const uint32_t below_layers = 0) const;
    NGrid stationary() const;
    NGrid stationary_log() const;
    NGrid stationary_fract(float_t degree = 1.0f, float_t exponent = 1.0f) const;
    NGrid sort() const;
    NGrid pool_max(const int32_t slider_rows = 2, const int32_t slider_cols = 1, const int32_t slider_depth = 1) const;
    NGrid pool_maxabs(const int32_t slider_rows = 2, const int32_t slider_cols = 1, const int32_t slider_depth = 1) const;
    NGrid pool_min(const int32_t slider_rows = 2, const int32_t slider_cols = 1, const int32_t slider_depth = 1) const;
    NGrid pool_mean(const int32_t slider_rows = 2, const int32_t slider_cols = 1, const int32_t slider_depth = 1) const;
    NGrid convolution(const NGrid& kernel, bool padding = false) const;
    NGrid transpose() const;
    NGrid inverse(const float_t tolerance = 0.00001f, const uint32_t max_iterations = 20) const;
    NGrid mirror(bool mirror_rows = true, bool mirror_cols = true, bool mirror_depth = true) const;
    NGrid diagonal() const;
    NGrid upper_trigonal() const;
    NGrid lower_trigonal() const;
    NGrid remap(const NGrid& source, const NGrid& target, const NGrid& target_index_map_on_source) const;
    NGrid remap(const NGrid& target_index_map_on_source) const;

    // +=================================+   
    // | 1d vector statistics            |
    // +=================================+

    struct CorrelationResult;
    struct RegressionResult;

    CorrelationResult correlation(const NGrid& other) const;
    RegressionResult regression(const NGrid& other, const uint32_t power = 1) const;
    float_t Dickey_Fuller() const;
    float_t Engle_Granger(const NGrid& other) const;
    float_t covariance(const NGrid& other) const;

    // +=================================+   
    // | Output                          |
    // +=================================+
    
    void print(std::string comment = "", std::string delimiter = "|", bool with_indices = false, bool rows_inline = false, int32_t precision = 3) const;

	static VulkanManager* manager;        // shared singleton manager for instance, device and command pool
    static DescriptorPool* descriptor_pool;

protected:

    // +=================================+   
    // | Protected Class Members         |
    // +=================================+
	std::vector<uint32_t> shape = {};           // shape of the array
	uint32_t dimensions = 0;                    // number of dimensions
	uint32_t elements = 0;                      // total number of elements
    CommandBuffer* command_buffer = nullptr;
    Buffer<float_t>* data_buffer = nullptr;
    

    uint32_t flat_index(uint32_t row, uint32_t col = 0, uint32_t depth_layer = 0) const;

    void copy_resources(const NGrid& other);

};


// +=================================+   
// | Static Member Initializations   |
// +=================================+
VulkanManager* NGrid::manager = nullptr;
DescriptorPool* NGrid::descriptor_pool = nullptr;




// DEFINITIONS
// ===============================================================================================================================


// +=================================+   
// | Constructors & Destructors      |
// +=================================+

// parametric default constructor for multi-dimensional array
NGrid::NGrid(std::initializer_list<uint32_t> shape) :
    shape(shape),
    dimensions(shape.size()) {
    elements = 1;
    for (uint32_t i = 0; i < shape.size(); ++i) {
        elements *= this->shape[i];
    }
	if (elements == 0) {
        Log::error("invalid usage of constructor 'NGrid(std::initializer_list<uint32_t> shape)' with empty shape; ",
                   "one or more dimensions have size 0, therefore the product of the dimension sizes is also 0");
	}

    // create a shared manager for instance, device and commandpool
    if (VulkanManager::get_singleton() == nullptr) {
        manager = VulkanManager::make_singleton_for_compute(1,3,0);
    }
    else {
        manager = VulkanManager::get_singleton();
    }

	// create a descriptor pool for the command buffer
    if (descriptor_pool == nullptr) {
        static constexpr uint32_t max_sets = 1; // = single set because only one per operation is needed; goes out of scope afterwards
		std::vector<VkDescriptorPoolSize> max_buffers = {
			{ VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 20 },
			{ VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 20 }
		};
		descriptor_pool = new DescriptorPool(manager->get_device(), max_sets, max_buffers);
    }

    // create a command buffer
    command_buffer = new CommandBuffer(manager->get_device(), QueueFamily::COMPUTE, manager->get_command_pool_compute());
    
    // allocate as a 'flat' buffer -> this is required because GLSL shaders only support dynamic sizing in a single (=the last) dimension
    VkMemoryPropertyFlags memory_properties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
    data_buffer = new Buffer<float_t>(manager->get_device(), BufferUsage::STORAGE, this->elements, 1, 1, memory_properties);
}

// move constructor
NGrid::NGrid(NGrid&& other) noexcept {
    this->elements = other.elements;
    this->dimensions = other.dimensions;
    this->manager = other.manager;
    if (this->data_buffer != nullptr) {
        delete[] this->data_buffer;
    }
	this->data_buffer = other.data_buffer;
	this->command_buffer = std::move(other.command_buffer);
	this->descriptor_pool = std::move(other.descriptor_pool);
	this->shape = std::move(other.shape);
}

// NGrid copy constructor
NGrid::NGrid(const NGrid& other) {
    this->elements = other.elements;
    this->rows = other.rows;
    this->cols = other.cols;
    this->depth = other.depth;
    this->dimensions = other.dimensions;
    this->manager = other.manager;
    if (this->command_buffer == nullptr) {
        this->command_buffer = new CommandBuffer(manager->get_device(), QueueFamily::COMPUTE, manager->get_command_pool_compute());
    }

    if (data_buffer != nullptr) {
        delete this->data_buffer;
    }

    VkMemoryPropertyFlags memory_properties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
    data_buffer = new Buffer<float_t>(manager->get_device(), BufferUsage::STORAGE, this->elements, 1, 1, memory_properties);
    this->data_buffer = other.data_buffer;
}

// destructor
NGrid::~NGrid() {
	// destroy in reverse order of creation
    if (this->data_buffer != nullptr) {
        delete this->data_buffer;
        this->data_buffer = nullptr;
    }
    if (this->command_buffer) {
        delete this->command_buffer;
        this->command_buffer = nullptr;
    }
    if (descriptor_pool != nullptr) {
        delete descriptor_pool;
        descriptor_pool = nullptr;
    }
}

// +=================================+   
// | getters & setters               |
// +=================================+

// assigns a value to a data element via its index
void NGrid::set(const float_t value, const uint32_t row_index, const uint32_t col_index, const uint32_t layer_index) {
    // using flat index as 'row' index
    this->data_buffer->set(value, row_index * this->cols * this->depth + col_index * this->depth + layer_index);
}

// copies raw data from a std::vector<float_t> to the data buffer
// of the underlying NGrid array
void NGrid::set(std::vector<float_t>& data) {
    data_buffer->write(data);
}

// returns the value of an array element via its flattened index
float_t NGrid::get(const uint32_t row_index, const uint32_t col_index, const uint32_t layer_index) const {
    // using flat index as 'row' index
    return data_buffer->get(row_index * this->cols * this->depth + col_index * this->depth + layer_index);
}

// returns a flat copy of the raw data of the underlying buffer as type std::vector<float_t>
std::vector<float> NGrid::get() const {
    return data_buffer->read();
}

// returns the buffer containg the raw array data
Buffer<float_t>* NGrid::get_data_buffer() const {
    return this->data_buffer;
}

// returns the number of dimensions of the underlying array
uint32_t NGrid::get_dimensions() const {
    return this->dimensions;
}

// returns the number of rows, i.e. the size of the first dimension (indexed 0)
uint32_t NGrid::get_rows() const {
    return this->rows;
}

// returns the number of columns, i.e. the size of the second dimension (indexed 1)
uint32_t NGrid::get_cols() const {
    return this->cols;
}

// returns the array depth,
// i.e. the size of the third dimension (indexed 2)
uint32_t NGrid::get_depth() const {
    return this->depth;
}

// returns the total number of elements of the underlying array
uint32_t NGrid::get_elements() const {
    return this->elements;
}

// returns the shape of the array as std::string
std::string NGrid::get_shapestring() const {
    std::string result = "{";
    if (this->rows > 0) { result += std::to_string(this->rows); }
    if (this->cols > 1 || this->depth > 1) { result += ","; result += std::to_string(this->cols); }
    if (this->depth > 1) { result += ","; result += std::to_string(this->depth); }
    result += "}";
    return result;
}

// returns a single row sliced from a 2d or 3d array
NGrid NGrid::get_row(int32_t row_index)  const {
    NGrid result(1, this->cols, this->depth);

    if (this->dimensions == 1) {
        Log::log(WARNING, "usage of method 'NGrid get_row(uint32_t row_index)' with a 1d array -> result contains a single scalar; ",
            "this isn't strictly invalid, but for better efficiency consider using 'float_t get(uint32_t row)' instead");
        result.set(this->get(row_index), 0);
        return result;
    }

    if (row_index >= this->rows || row_index < 0) {
        Log::log(ERROR, "invalid usage of method 'NGrid get_row(uint32_t row_index)' with invalid row index; index is ", row_index, ", the underlying array has ", this->rows, " row(s)");
    }

    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("get_row.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(row_index);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    this->descriptor_pool->release_sets();
    return result;
}

// returns a single column sliced from a 2d or 3d array
NGrid NGrid::get_col(int32_t col_index) const {
    NGrid result(this->rows, 1, this->depth);

    if (col_index >= this->cols || col_index < 0) {
        Log::log(ERROR, "invalid usage of method 'NGrid get_col(uint32_t col_index)' with invalid column index; index is ", col_index, ", the underlying array has ", this->cols, " column(s)");
    }
    
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("get_col.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(col_index);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    
	this->descriptor_pool->release_sets();
    return result;
}

// returns a single depth layer sliced from a 3d array
NGrid NGrid::get_layer(int32_t layer_index) const {
    NGrid result(this->rows, this->cols, 1);

    if (layer_index >= this->depth || layer_index < 0) {
        Log::log(ERROR, "invalid usage of method 'NGrid get_layer(uint32_t layer_index)' with invalid depth layer index; index is ", layer_index, ", the underlying array has ", this->depth, " depth layer(s)");
    }

    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("get_layer.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(layer_index);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// +=================================+   
// | Fill, Initialize                |
// +=================================+

// fill entire array with given floating point value
void NGrid::fill(const float_t value) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// initialize the entire array with zeros
void NGrid::fill_zero() {
    this->fill(0.0f);
}

// fill entire array with identity matrix
void NGrid::fill_identity() {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_identity.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fill with values from a random normal (=gaussian) distribution
void NGrid::fill_random_gaussian(const float_t mu, const float_t sigma) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_random_gaussian.spv"); }
    
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values(seed32());
    push_constants.add_values(mu);
    push_constants.add_values(sigma);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fill with values from a random uniform distribution
void NGrid::fill_random_uniform(const float_t min, const float_t max) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_random_uniform.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());
    push_constants.add_values(min);
    push_constants.add_values(max);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fill with values from a random uniform distribution
void NGrid::fill_random_uniform_int(const int32_t min, const int32_t max) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_random_uniform_int.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(Random::seed32());
    push_constants.add_values(min);
    push_constants.add_values(max);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// randomly sets the specified fraction of the values to zero and the rest to 1 (default: 0.5, i.e. 50%)
void NGrid::fill_random_binary(float_t ratio) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_random_binary.spv"); }

    // check valid ratio
    if (ratio > 1 || ratio < 0) {
        Log::log(WARNING,
            "invalid usage of method 'void NGrid::fill_binary(float_t ratio)': "
            "ratio argument must be between 0-1 but is ", ratio,
            " --> argument will be clipped to fit this range");
    }
    float_t valid_ratio = std::fmax(std::fmin(ratio, 1.0f), 0);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());
    push_constants.add_values(valid_ratio);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// randomly sets the specified fraction of the values to -1 and the rest to +1 (default: 0.5, i.e. 50%)
void NGrid::fill_random_sign(float_t ratio) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_random_sign.spv"); }

    // check valid ratio
    if (ratio > 1 || ratio < 0) {
        Log::log(WARNING,
            "invalid usage of method 'void NGrid::fill_sign(float_t ratio)': "
            "ratio argument must be between 0-1 but is ", ratio,
            " --> argument will be clipped to fit this range");
    }
    float_t valid_ratio = std::fmax(std::fmin(ratio, 1.0f), 0);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());
    push_constants.add_values(valid_ratio);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}


// fills the array with a continuous
// range of numbers (with specified start parameter
// referring to the zero position and a step parameter)
// in all dimensions
void NGrid::fill_range(const float_t start, const float_t step) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_range.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->rows);
    push_constants.add_values(this->cols);
    push_constants.add_values(this->depth);
    push_constants.add_values(start);
    push_constants.add_values(step);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

void NGrid::fill_dropout(float_t ratio) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_dropout.spv"); }

    // check valid ratio
    if (ratio > 1 || ratio < 0) {
        Log::log(WARNING,
            "invalid usage of method 'void NGrid::fill_dropout(float_t ratio)': "
            "ratio argument must be between 0-1 but is ", ratio,
            " --> argument will be clipped to fit this range");
    }
    float_t valid_ratio = std::fmax(std::fmin(ratio, 1.0f), 0);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());
    push_constants.add_values(ratio);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fill with normal "Xavier" weight initialization
// (by Xavier Glorot & Bengio) for tanh activation
void NGrid::fill_Xavier_normal(uint32_t fan_in, uint32_t fan_out) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_Xavier_normal.spv"); }

    static std::vector<DescriptorType> types = {
    STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());
    push_constants.add_values(fan_in);
    push_constants.add_values(fan_out);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fill with uniform "Xavier" weight initializiation
// (by Xavier Glorot & Bengio), e.g. for tanh activation
void NGrid::fill_Xavier_uniform(uint32_t fan_in, uint32_t fan_out) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_Xavier_uniform.spv"); }

    float_t seed = (float_t)(double(rand()) / RAND_MAX);

    static std::vector<DescriptorType> types = {
    STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed);
    push_constants.add_values(fan_in);
    push_constants.add_values(fan_out);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fill with uniform "Xavier" weight initialization
// for sigmoid activation
void NGrid::fill_Xavier_sigmoid(uint32_t fan_in, uint32_t fan_out) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_Xavier_sigmoid.spv"); }

    static std::vector<DescriptorType> types = {
    STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());
    push_constants.add_values(fan_in);
    push_constants.add_values(fan_out);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fill with "Kaiming He" normal weight initialization,
// used for ReLU activation
void NGrid::fill_He_ReLU(uint32_t fan_in) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_He_ReLU.spv"); }

    static std::vector<DescriptorType> types = {
    STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());
    push_constants.add_values(fan_in);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fill with modified "Kaiming He" nornal weight initialization,
// used for ELU activation
void NGrid::fill_He_ELU(uint32_t fan_in) {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_He_ELU.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());
    push_constants.add_values(fan_in);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// fills the array elements with their flat indices
void NGrid::fill_index() {
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("fill_index.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
}

// +=================================+   
// | Distribution Properties         |
// +=================================+

// returns the lowest value of the NGrid,
// across all dimensions
float_t NGrid::min() const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("min.spv"); }
    
    Buffer<float> result(manager->get_device(), STORAGE, this->elements);
    Buffer<uint32_t> signal(manager->get_device(), STORAGE, workgroups);
    
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types);
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(result, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    
    pipeline.destroy();
    descriptor_set.destroy();
    
    return result.get(0);
}

// returns the highest value of the NGrid,
// across all dimensions
float_t NGrid::max() const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("max.spv"); }

    Buffer<float> result(manager->get_device(), STORAGE, this->elements);
    Buffer<uint32_t> signal(manager->get_device(), STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types);
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(result, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result.get(0);
}

// returns the value of the NGrid with the highest
// deviation from zero, across all dimensions
float_t NGrid::maxabs() const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("maxabs.spv"); }

    Buffer<float> result(manager->get_device(), STORAGE, this->elements);
    Buffer<uint32_t> signal(manager->get_device(), STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types);
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(result, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result.get(0);
}

// returns the arrithmetic mean of all values of the NGrid
float_t NGrid::mean() const {
    return this->sum() / this->elements;
}

// returns the median of all values the NGrid;
// NGrid must be 1d
float_t NGrid::median() const {

    // confirm 1d array
    if (this->dimensions > 1) {
        Log::log(ERROR, "invalid usage of method NGrid::median(), underlying array must be 1d but has ", this->dimensions, " dimensions");
    }

    NGrid sorted = this->sort();
    // odd number of elements
    if (this->rows % 2) {
        return sorted.get(elements / 2);
    }
    // even number of elements
    else {
        return (sorted.get(elements / 2 - 1) + sorted.get(elements / 2)) / 2;
    }
}

// returns the variance of all values of a vector, matrix or array
// as a floating point number
float_t NGrid::variance() const {
    // std::cout << "expected variance result: " << (this->operator-((this->operator/(elements)).sum())).pow().operator/(elements - 1).sum() << std::endl;
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;
    
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("variance.spv"); }

    Buffer<float> partial_sum(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<float> mdev2(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);
    Buffer<float> result(manager->get_device(), BufferUsage::STORAGE, 1);
    
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };
    
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(result, 1);
    descriptor_set.bind_buffer(partial_sum, 2);
    descriptor_set.bind_buffer(mdev2, 3);
    descriptor_set.bind_buffer(signal, 4);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    
    return result.get(0);
}

// returns the standard deviation of all values a the vector, matrix or array
float_t NGrid::stddev() const {
    return std::sqrt(this->variance());
}

// returns the skewness of all data of the NGrid
// across all dimensions
float_t NGrid::skewness() const {
    // TODO: check this code and its shader again; result isn't correct
    NGrid mdev = this->operator-(this->mean());
    //std::cout << "expected result = " << mdev.pow(2).sum()/elements / std::pow(mdev.pow(3).sum()/elements, 1.5) << std:: endl;

    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("skewness.spv"); }

    Buffer<float> partial_sum(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<float> mdev2(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<float> mdev3(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<float> result(manager->get_device(), BufferUsage::STORAGE, 1);
    Buffer<uint32_t> signal(manager->get_device(), STORAGE, workgroups);
    
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, descriptor_types(STORAGE_BUFFER, 7)); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(partial_sum, 1);
    descriptor_set.bind_buffer(mdev2, 2);
    descriptor_set.bind_buffer(mdev3, 3);
    descriptor_set.bind_buffer(result, 4);
    descriptor_set.bind_buffer(signal, 5);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result.get(0);
}

// returns the kurtosis of all data of the NGrid
// across all dimensions
float_t NGrid::kurtosis() const {
    // TODO: check this code and its shader again; result isn't correct
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("kurtosis.spv"); }

    Buffer<float> partial_sum(manager->get_device(), BufferUsage::STORAGE, workgroups);
    Buffer<float> mdev2(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<float> mdev4(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<float> result(manager->get_device(), BufferUsage::STORAGE, 1);
    Buffer<uint32_t> signal(manager->get_device(), STORAGE, workgroups);
    
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(partial_sum, 1);
    descriptor_set.bind_buffer(mdev2, 2);
    descriptor_set.bind_buffer(mdev4, 3);
    descriptor_set.bind_buffer(result, 4);
    descriptor_set.bind_buffer(signal, 5);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result.get(0);
}

// returns the Euklidean norm (=distance from origin)
float NGrid::norm() const {
    return this->pow(2).sum();
}

// +=================================+   
// | Addition                        |
// +=================================+

// returns the sum of all array elements;
float_t NGrid::sum() const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("sum.spv"); }
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);
    Buffer<float> result(manager->get_device(), BufferUsage::STORAGE, this->elements);
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(result, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result.get(0);
}

// elementwise addition of the specified value to all values of the array
NGrid NGrid::operator+(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);
    
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("operator_plus_value.spv"); }
    
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };
    
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// returns the resulting array of the elementwise addition of two arrays
NGrid NGrid::operator+(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);
    
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("operator_plus_other.spv"); }
    
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };
    
    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({this->rows, this->cols, this->depth});
    push_constants.add_values({other.rows, other.cols, other.depth});

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// prefix increment operator;
// increments the values of the array by +1,
// returns a reference to the source array itself
NGrid& NGrid::operator++() {
    *this += 1.0f;
    return *this;
}

// postfix increment operator;
// makes an internal copy of the array,
// then increments all values of the array by +1,
// then returns the temporary copy;
// note: more overhead then with the prefix increment
// because of extra copy!
NGrid NGrid::operator++(int) {
    NGrid copy(this->rows, this->cols, this->depth);
    copy = *this;
    *this += 1.0f;
    return copy;
}

// elementwise addition of the specified
// value to the elements of the array
void NGrid::operator+=(const float_t value) {
    *this = this->operator+(value);
}

// elementwise addition of the values of 'other'
// to the values of the corresponding elements of 'this'
void NGrid::operator+=(const NGrid& other) {
    *this = this->operator+(other);
}


// +=================================+   
// | Substraction                    |
// +=================================+

// elementwise substraction of the specified value from all values of the array
NGrid NGrid::operator-(const float_t value) const {
    // using the member method "NGrid operator+(const float_t value) const"
    return this->operator+(value * -1);
}

// returns the resulting array of the elementwise substraction of
// two array of equal dimensions
NGrid NGrid::operator-(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("operator_minus_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.rows, other.cols, other.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// prefix decrement operator;
// decrements the values of the array by -1
NGrid& NGrid::operator--() {
    *this = *this + (-1.0f);
    return *this;
}

// postfix decrement operator;
// makes an internal copy of the array,
// then decrements all values of the array by -1,
// then returns the temporary copy;
// note: more overhead then with the prefix decrement
// because of extra copy!
NGrid NGrid::operator--(int) {
    NGrid copy(this->rows, this->cols, this->depth);
    copy= *this;
    *this = *this + (-1.0f);
    return copy;
}

// elementwise substraction of the specified
// value from the elements of the array
void NGrid::operator-=(const float_t value) {
    *this = *this + (value * -1);
}

// elementwise substraction of the values of 'other'
// from the values of the corresponding elements of 'this'
void NGrid::operator-=(const NGrid& other) {
    *this = this->operator-(other);
}

// +=================================+   
// | Multiplication                  |
// +=================================+

// returns the product reduction, i.e. the result
// of multiplication all individual elements of the array
float_t NGrid::product() const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("product.spv"); }

    Buffer<float> result(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(result, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result.get(0);
}

// elementwise multiplication with a scalar
NGrid NGrid::operator*(const float_t factor) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("operator_multiply_factor.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// elementwise multiplication (*=) with a scalar
void NGrid::operator*=(const float_t factor) {
    *this = this->operator*(factor);
}

// Alias for 2D or 3D matrix multiplication
NGrid NGrid::operator*(const NGrid& other) const {
    return this->matrix_product(other);
}

// Alias for 2D or 3D matrix multiplication;
// note: 'this' is getting reassigned and may change its shape as a consequence of this operation
void NGrid::operator*=(const NGrid& other) {
    *this = this->matrix_product(other);
}

// scalar product
float_t NGrid::scalar_product(const NGrid& other) const {
    return this->Hadamard_product(other).sum();
}

// 2D or 3d matrix dotproduct
NGrid NGrid::matrix_product(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, other.get_cols(), this->depth);
        
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("matrix_product.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, result.get_elements(), 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// elementwise multiplication of the values of the current
// array with the corresponding values of a second array,
// resulting in the 'Hadamard product';
// the dimensions of the two arrays must match!
// if they don't: only the common elements will be part of the result array
NGrid NGrid::Hadamard_product(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(std::min(this->rows, other.get_rows()), std::min(this->cols, other.get_cols()), std::min(this->depth, other.get_depth()));
    
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("hadamard_product.spv"); }
    
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    
    return result;
}

// +=================================+   
// | Division                        |
// +=================================+

// elementwise division by a scalar
NGrid NGrid::operator/(const float_t quotient) const {
    if (quotient == 0) {
        Log::log(ERROR,
            "invalid call of method 'NGrid NGrid::operator/(const T quotient)' ",
            "with quotient=0 (zero division is undefined)");
    }
    return (*this) * (1.0f / quotient);
}

// elementwise division (/=) by a scalar
void NGrid::operator/=(const float_t quotient) {
    (*this) *= (1.0f / quotient);
}

// elementwise division of the values of the current
// array by the corresponding values of a second NGrid,
// resulting in the 'Hadamard division';
// the dimensions of the two arrays must match!
NGrid NGrid::Hadamard_division(const NGrid& other) {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(std::min(this->rows, other.get_rows()), std::min(this->cols, other.get_cols()), std::min(this->depth, other.get_depth()));

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("hadamard_division.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// +=================================+   
// | Modulo                          |
// +=================================+

// elementwise modulo operation, converting the NGrid values
// to the remainders of their division by the specified number
void NGrid::operator%=(const float_t value) {
    *this = this->operator%(value);
}

// elementwise modulo operation, resulting in an NGrid array that
// contains the remainders of the division of the values of
// the original array by the specified number
NGrid NGrid::operator%(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    if (value == 0) {
        Log::log(WARNING,
            "invalid usage of method 'NGrid NGrid::operator%(const float_t value) const' ",
            "with value=0 (zero division is undefined) --> 'this' will remain unmodified");
        return *this;
    }
    
    NGrid result(this->rows, this->cols, this->depth);
    
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("operator_modulo_value.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// +=================================+   
// | Exponentiation & Logarithm      |
// +=================================+

// elementwise exponentiation to the power of
// the specified exponent
NGrid NGrid::pow(const float_t exponent) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);
    
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("pow.spv"); }
    
    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(exponent);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// alias for pow(exponent):
// elementwise exponentiation to the power of
// the specified exponent
NGrid NGrid::operator^(const float_t exponent) const {
    return this->pow(exponent);
}

// alias for pow(other):
// elementwise exponentiation to the power of
// the corresponding element of 'other'
NGrid NGrid::operator^(const NGrid& other) const {
    return this->pow(other);
}

// elementwise exponentiation of the values of 'this'
// to the power of the specified exponent
void NGrid::operator^=(const float_t exponent) {
    *this = this->pow(exponent);
}

// elementwise exponentiation to the power of
// the corresponding values of the second array;
// the dimensions of the two array must match!
NGrid NGrid::pow(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(std::min(this->rows, other.get_rows()), std::min(this->cols, other.get_cols()), std::min(this->depth, other.get_depth()));

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("pow_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// converts the individual values of the array
// elementwise to their square root
NGrid NGrid::sqrt() const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("sqrt.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::log(float_t base) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("log.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(base);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::exp() const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("exp.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// +=================================+   
// | Rounding                        |
// +=================================+

// rounds the values of the array elementwise
// to their nearest integers
NGrid NGrid::round() const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("round.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// rounds the values of the array elementwise
// to their next lower integers
NGrid NGrid::floor() const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("floor.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// returns a copy of the array that stores the values as rounded
// to their next higher integers
NGrid NGrid::ceil() const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("ceil.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// returns a copy of the array that stores the
// absolute values of the source array
NGrid NGrid::abs() const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("abs.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// +=================================+   
// | Min, Max                        |
// +=================================+

// elementwise minimum of the specified value
// and the data elements of the array
NGrid NGrid::min(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("min_value.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise maximum of the specified value
// and the data elements of the array
NGrid NGrid::max(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("max_value.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// returns the result of elementwise min() comparison
// of 'this' vs 'other'
NGrid NGrid::min(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("min_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// returns the result of elementwise max() comparison
// of 'this' vs 'other'
NGrid NGrid::max(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("max_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// +=================================+   
// | Trigonometric Functions         |
// +=================================+

// elementwise application of the cos() function
NGrid NGrid::cos(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("cos.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the sin() function
NGrid NGrid::sin(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("sin.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the tan function
NGrid NGrid::tan(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("tan.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the acos() function
NGrid NGrid::acos(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("acos.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the asin() function
NGrid NGrid::asin(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("asin.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the atan function
NGrid NGrid::atan(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("atan.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the hyperbolic cosine function
NGrid NGrid::cosh(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("cosh.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise applicatiohn of the hyperbolic sine function
NGrid NGrid::sinh(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("sinh.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the hyperbolic tangent function
NGrid NGrid::tanh(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("tanh.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the hyperbolic arc cosine function
NGrid NGrid::acosh(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("acosh.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the hyperbolic arc sine function
NGrid NGrid::asinh(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("asinh.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// elementwise application of the hyperbolic arc tangent function
NGrid NGrid::atanh(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("atanh.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// +=================================+   
// | Find, Replace                   |
// +=================================+

// searches the array buffer for the specified 'old_value' and
// replaces all occurrences by the 'new_value';
// in order to mitigate floating point number rounding imprecisions,
// this method will consider any values that no more than
// epsilon = 0.0000001 from the old value as a match
NGrid NGrid::replace(const float_t& old_value, const float_t& new_value) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("replace.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(old_value);
    push_constants.add_values(new_value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// replaces all elements of 'this' with the corresponding element of the
// 'replacing_map' if the corresponding element of the condition map is !=0
NGrid NGrid::replace_if(const NGrid& condition_map, const NGrid& replacing_map) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("replace_if_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*condition_map.data_buffer, 1);
    descriptor_set.bind_buffer(*replacing_map.data_buffer, 2);
    descriptor_set.bind_buffer(*result.data_buffer, 3);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth} );
    push_constants.add_values({ condition_map.rows, condition_map.cols, condition_map.depth });
    push_constants.add_values({ replacing_map.rows, replacing_map.cols, replacing_map.depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// replaces all elements of 'this' with the corresponding element of the
// 'replacing_map' if the corresponding element of the condition map is !=0
NGrid NGrid::replace_if(const NGrid& condition_map, const float_t replacing_value) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("replace_if_value.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*condition_map.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ condition_map.rows, condition_map.cols, condition_map.depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(replacing_value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// returns the number of occurrences of the specified value;
// in order to mitigate floating point number rounding imprecisions,
// this method will consider any values that differ by no more than
// epsilon = 0.0000001 from the old value as a match
uint32_t NGrid::find(const float_t& value) const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("find.spv"); }

    Buffer<float> result(manager->get_device(), BufferUsage::STORAGE, this->elements);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(result, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result.get(0);
}

// returns a NGrid array of equal dimensions as the source,
// with -1 for all corresponding negative values and +1 for all corresponding positive values
// (0 for all zeros)
NGrid NGrid::sign() const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("sign.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// +=================================+   
// | Scaling                         |
// +=================================+

// scale to specified range
NGrid NGrid::scale_minmax(float_t range_from, float_t range_to) const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("scale_minmax.spv"); }

    NGrid result(this->rows, this->cols, this->depth);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(std::min(range_from, range_to));
    push_constants.add_values(std::max(range_from, range_to));

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// mean normalization scaling, i.e.
// (x - mean) / (max - min)
NGrid NGrid::scale_mean() const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("scale_mean.spv"); }

    NGrid result(this->rows, this->cols, this->depth);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// scaling to zero mean and unit-variance, i.e.
// (x - mean) / sigma
NGrid NGrid::scale_standardized() const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("scale_standardized.spv"); }

    NGrid result(this->rows, this->cols, this->depth);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// +=================================+   
// | Activation Functions            |
// +=================================+

NGrid NGrid::activation(ActFunc activation_function) const {
    switch (activation_function) {
    case ActFunc::RELU:
        return this->relu(0.0f);
        break;
    case ActFunc::LRELU:
        return this->relu(0.01f);
        break;
    case ActFunc::ELU:
        return this->elu(0.0f);
        break;
    case ActFunc::LELU:
        return this->elu(0.01f);
        break;
    case ActFunc::SIGMOID:
        return this->sigmoid();
        break;
    case ActFunc::TANH:
        return this->tanh();
        break;
    case ActFunc::IDENT:
        return this->ident();
        break;
    default:
        return *this;
        break;
    }
}

NGrid NGrid::derivative(ActFunc activation_function) const {
    switch (activation_function) {
    case ActFunc::RELU:
        return this->relu_drv(0.0f);
        break;
    case ActFunc::LRELU:
        return this->relu_drv(0.01f);
        break;
    case ActFunc::ELU:
        return elu_drv(0.0f);
        break;
    case ActFunc::LELU:
        return elu_drv(0.01f);
        break;
    case ActFunc::SIGMOID:
        return sigmoid_drv();
        break;
    case ActFunc::TANH:
        return tanh_drv();
        break;
    case ActFunc::IDENT:
        return ident_drv();
        break;
    default:
        return *this;
        break;
    }
}

// identity activation function
NGrid NGrid::ident() const {
    NGrid result;
    result = *this; // copy constructor invocation
    return result;
}

// identity activation function derivative
NGrid NGrid::ident_drv() const {
    NGrid result(this->rows, this->cols, this->depth);
    result.fill(1.0f);
    return result;
}

// sigmoid activation function
// 1/(1+exp(-x))
NGrid NGrid::sigmoid() const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("sigmoid.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// sigmoid activation derivative
// exp(x)/pow(exp(x)+1,2)
NGrid NGrid::sigmoid_drv() const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("sigmoid.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// ELU activation function
NGrid NGrid::elu(float_t alpha) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("elu.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(alpha);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// ELU activation derivative;
// chose alpha=0 for true ELU function;
// small alpha value like e.g. 0.01 for 'leaky' ELU
NGrid NGrid::elu_drv(float_t alpha) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("elu_drv.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(alpha);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}


// ReLU activation function;
// chose alpha=0 for true ReLU function;
// small alpha value like e.g. 0.01 for 'leaky' ReLU
NGrid NGrid::relu(float_t alpha) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("relu.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(alpha);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// ReLU activation derivative;
// chose alpha=0 for true ReLU function;
// small alpha value like e.g. 0.01 for 'leaky' ReLU
NGrid NGrid::relu_drv(float_t alpha) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("relu_drv.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(alpha);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// tanh activation derivative
NGrid NGrid::tanh_drv(AngularMeasure unit) const {
    float_t factor = angle(1.0f, unit, RAD, false); // conversion factor from source unit to radians
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("tanh_drv.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(factor);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// +=================================+   
// | Outlier Treatment               |
// +=================================+

// returns a copy of the data array
// limited to the range from min_value to max_value
NGrid NGrid::outliers_truncate(const float_t min_value, const float_t max_value) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("outliers_minmax.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(std::min(min_value, max_value));
    push_constants.add_values(std::max(min_value, max_value));

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// truncate outliers by z-score mean deviation
NGrid NGrid::outliers_truncate(float_t z_score) const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("outliers_truncate.spv"); }

    NGrid result(this->rows, this->cols, this->depth);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(z_score);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// set outliers (by z-score) to mean
NGrid NGrid::outliers_mean_imputation(float_t z_score) const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("outliers_mean_imputation.spv"); }

    NGrid result(this->rows, this->cols, this->depth);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(z_score);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// set outliers (by z-score) to value
NGrid NGrid::outliers_value_imputation(float_t value, float_t z_score) const {
    static constexpr uint32_t workgroup_size = 256;
    const uint32_t workgroups = this->elements / workgroup_size + 1;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("outliers_value_imputation.spv"); }

    NGrid result(this->rows, this->cols, this->depth);
    Buffer<uint32_t> signal(manager->get_device(), BufferUsage::STORAGE, workgroups);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);
    descriptor_set.bind_buffer(signal, 2);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(z_score);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// recover -inf, +inf or nan values
NGrid NGrid::recover() const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("recover.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(seed32());

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// +=================================+   
// | Assignment                      |
// +=================================+

// copy assignment
NGrid& NGrid::operator=(const NGrid& other) {
    // Check for self-assignment
    if (this != &other) {
        this->elements = other.elements;
        this->rows = other.rows;
        this->cols = other.cols;
        this->depth = other.depth;
        this->dimensions = other.dimensions;
        *this->data_buffer = *other.data_buffer;
    }
    return *this;
}

// move assignment
NGrid& NGrid::operator=(NGrid&& other) noexcept {
    // Check for self-assignment
    if (this != &other) {
        // Move data from other object
        this->elements = other.elements;
        this->rows = other.rows;
        this->cols = other.cols;
        this->depth = other.depth;
        this->dimensions = other.dimensions;
        *this->data_buffer = std::move(*other.data_buffer);
    }
    return *this;
}

// +=================================+   
// | Elementwise Comparison          |
// +=================================+

NGrid NGrid::operator>(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("greater_value.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}


NGrid NGrid::operator>=(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("greaterequals_value.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::operator==(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("equals_value.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::operator!=(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("notequals_value.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::operator<(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("less_value.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::operator<=(const float_t value) const {
    static constexpr uint32_t workgroup_size = 256;

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("lessequals_value.spv"); }

    NGrid result(this->rows, this->cols, this->depth);

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// elementwise comparison with second NGrid
NGrid NGrid::operator>(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("greater_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::operator>=(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("greaterequals_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::operator==(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("equals_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::operator!=(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("notequals_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}
NGrid NGrid::operator<(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("less_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::operator<=(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("lessequals_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}


// +=================================+   
// | Elementwise Logial Operations   |
// +=================================+

// elementwise logical 'and'
NGrid NGrid::operator&&(const bool value) const {
    if (value == false) {
        NGrid result(this->rows, this->cols, this->depth);
        result.fill(0);
        return result;
    }
    else {
        return this->operator!=(0.0f);
    }
}

// elementwise logical 'or'
NGrid NGrid::operator||(const bool value) const {
    if (value == true) {
        NGrid result(this->rows, this->cols, this->depth);
        result.fill(1);
        return result;
    }
    else {
        return this->operator!=(0.0f);
    }
}

// elementwise 'not'
NGrid NGrid::operator!() const {
    return this->operator==(0.0f);
}

NGrid NGrid::operator&&(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("and_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::operator||(const NGrid& other) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->rows, this->cols, this->depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("or_other.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.get_rows(), other.get_cols(), other.get_depth() });
    push_constants.add_values({ result.get_rows(), result.get_cols(), result.get_depth() });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// +=================================+   
// | dynamic handling                |
// +=================================+

// conversion from 2d or 3d array to 1d vector
NGrid NGrid::flatten() const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(this->elements, 1, 1);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("flatten.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values(this->elements);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// add the specified number of rows;
// a default value can be passed for initialization of any newly added elements;
// a negative number of added rows can be used to remove rows
NGrid NGrid::add_rows(const int32_t rows, float_t init_value) const {
    return this->resize(this->rows + rows, this->cols, this->depth, init_value);
}

// add the specified number of columns;
// a default value can be passed for initialization of any newly added elements;
// a negative number of added columns can be used to remove columns
NGrid NGrid::add_cols(const int32_t cols, float_t init_value) const {
    return this->resize(this->rows, this->cols + cols, this->depth, init_value);
}

// add the specified depth layers to the z dimension;
// a default value can be passed for initialization of any newly added elements;
// a negative number of added depth can be used to remove a number of z dimension layers
NGrid NGrid::add_depth(const int32_t layers, float_t init_value) const {
    return this->resize(this->rows, this->cols, this->depth + layers, init_value);
}

// resizes the underlying array buffer to the specified dimensions;
// any new elements get initialized to the given value (default: 0)
NGrid NGrid::resize(const uint32_t rows, const uint32_t cols, const uint32_t depth, float_t init_value) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(rows, cols, depth);

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("resize.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(init_value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// stitch two NGrid arrays together along the specified axis
NGrid NGrid::concatenate(const NGrid& other, const uint32_t axis) const {
    static constexpr uint32_t workgroup_size = 256;
    if (axis > 2) {
        Log::log(ERROR, "in method NGrid::concatenate() invalid axis argument (axis is ", axis, " but no values > 2 are allowed)");
    }
    NGrid result(
        axis == 0 ? this->rows + other.get_rows() : this->rows,
        axis == 1 ? this->cols + other.get_cols() : this->cols,
        axis == 2 ? this->depth + other.get_depth() : this->depth
    );
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("concatenate.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*other.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ other.rows, other.cols, other.depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

// padding around vector/matrix/array using the passed value 
NGrid NGrid::padding(const float_t value, const uint32_t before_rows, const uint32_t after_rows, const uint32_t before_cols, const uint32_t after_cols, const uint32_t above_layers, const uint32_t below_layers) const {
    static constexpr uint32_t workgroup_size = 256;

    NGrid result(
        before_rows + this->rows + after_rows,
        before_cols + this->cols + after_cols,
        above_layers + this->depth + below_layers
    );

    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("padding.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values({ before_rows, before_cols, above_layers });
    push_constants.add_values(value);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::pool_max(const int32_t slider_rows, const int32_t slider_cols, const int32_t slider_depth) const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(
        std::max(int(std::ceil(float_t(this->rows) / slider_rows)), 1),
        std::max(int(std::ceil(float_t(this->cols) / slider_cols)), 1),
        std::max(int(std::ceil(float_t(this->depth) / slider_depth)), 1)
    );
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("pool_max.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values({ slider_rows, slider_cols, slider_depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);

    pipeline.destroy();
    descriptor_set.destroy();

    return result;
}

NGrid NGrid::pool_maxabs(const int32_t slider_rows, const int32_t slider_cols, const int32_t slider_depth) const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(
        std::max(int(std::ceil(float_t(this->rows) / slider_rows)), 1),
        std::max(int(std::ceil(float_t(this->cols) / slider_cols)), 1),
        std::max(int(std::ceil(float_t(this->depth) / slider_depth)), 1)
    );
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("pool_maxabs.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values({ slider_rows, slider_cols, slider_depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::pool_min(const int32_t slider_rows, const int32_t slider_cols, const int32_t slider_depth) const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(
        std::max(int(std::ceil(float_t(this->rows) / slider_rows)), 1),
        std::max(int(std::ceil(float_t(this->cols) / slider_cols)), 1),
        std::max(int(std::ceil(float_t(this->depth) / slider_depth)), 1)
    );
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("pool_min.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values({ slider_rows, slider_cols, slider_depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::pool_mean(const int32_t slider_rows, const int32_t slider_cols, const int32_t slider_depth) const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(
        std::max(int(std::ceil(float_t(this->rows) / slider_rows)), 1),
        std::max(int(std::ceil(float_t(this->cols) / slider_cols)), 1),
        std::max(int(std::ceil(float_t(this->depth) / slider_depth)), 1)
    );
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("pool_mean.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values({ slider_rows, slider_cols, slider_depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::convolution(const NGrid& kernel, bool padding) const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(
        padding ? this->rows : this->rows - kernel.get_rows() + 1,
        padding ? this->cols : this->cols - kernel.get_cols() + 1,
        padding ? this->depth : this->depth - kernel.get_depth() + 1
    );
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("convolution.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*kernel.data_buffer, 1);
    descriptor_set.bind_buffer(*result.data_buffer, 2);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ kernel.rows, kernel.cols, kernel.depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// turn rows into columns and vice versa
NGrid NGrid::transpose() const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(this->cols, this->rows, this->depth);
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("transpose.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// matrix inversion (via iterative approximation)
NGrid NGrid::inverse(const float_t tolerance,  const uint32_t max_iterations) const {
    NGrid X(this->cols, this->rows, this->depth); X.fill_random_uniform(-1.0f, 1.0f); // = initial guess, to be iteratively refined
    NGrid X_new(this->cols, this->rows, this->depth);
    NGrid I(this->rows, this->cols, this->depth); I.fill_identity();
    NGrid I2 = I * 2;
    for (uint32_t i = 0; i < max_iterations; i++) {
        X_new = X * (I2 - (*this) * X);
        X_new.print("X_new:");
        if (std::fabs((X - X_new).norm()) <= tolerance) {
            return X_new;
        }
        else {
            X = X_new;
        }
    }
    return X;
}

// reverse sorting
NGrid NGrid::mirror(bool mirror_rows, bool mirror_cols, bool mirror_depth) const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(this->rows, this->cols, this->depth);
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("mirror.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values({ int(mirror_rows), int(mirror_cols), int(mirror_depth) });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}


NGrid NGrid::diagonal() const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(this->rows, this->cols, this->depth);
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("diagonal.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::upper_trigonal() const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(this->rows, this->cols, this->depth);
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("upper_trigonal.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::lower_trigonal() const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(this->rows, this->cols, this->depth);
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("lower_trigonal.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// rearrange the source array elements based on a target index map (holding the flat indices)
NGrid NGrid::remap(const NGrid& source, const NGrid& target, const NGrid& target_index_map_on_source) const {
    static constexpr uint32_t workgroup_size = 256;
    NGrid result(target.rows, target.cols, target.depth);
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("remap.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*source.data_buffer, 0);
    descriptor_set.bind_buffer(*target.data_buffer, 1);
    descriptor_set.bind_buffer(*target_index_map_on_source.data_buffer, 2);
    descriptor_set.bind_buffer(*result.data_buffer, 3);

    PushConstants push_constants;
    push_constants.add_values({ source.rows, source.cols, source.depth });
    push_constants.add_values({ target_index_map_on_source.rows, target_index_map_on_source.cols, target_index_map_on_source.depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, source.elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::remap(const NGrid& target_index_map_on_source) const {
    return remap(*this, *this, target_index_map_on_source);
}

// +=================================+   
// | 1d vector statistics            |
// +=================================+

// return struct for correlation results
struct NGrid::CorrelationResult {
public:

    // predict a y value for a given x element, assuming linear correlation
    float_t predict(float_t x) const { return slope * x + y_intercept; }

    // print linear correlation results to the console
    void print() const {
        std::cout
            << "=========================================================================="
            << "\nCorrelation Results (this=x vs. other=y):"
            << "\n   - mean value of x = " << x_mean
            << "\n   - mean value of y = " << y_mean
            << "\n   - variance of x = " << x_variance
            << "\n   - variance of y = " << y_variance
            << "\n   - standard deviation of x = " << x_stddev
            << "\n   - standard deviation of y = " << y_stddev
            << "\n   - regression line y-intercept = " << y_intercept
            << "\n   - regression line slope = " << slope
            << "\n   - covariance between x & y = " << covariance
            << "\n   - Pearson correlation coefficient R = " << Pearson_R
            << "\n   - coefficient of determination (r-squared) = " << r_squared
            << "\n   - total sum of squares (SST) = " << SST
            << "\n   - explained sum of squares (SSE) = " << SSE
            << "\n   - residual sum of squares (SSR) = " << SSR
            << "\n   - mean squared error (MSE) = " << MSE
            << "\n   - mean squared regression (MSR) = " << MSR
            << "\n==========================================================================" << std::endl;
    }

    // constructor
    CorrelationResult(int elements) {
        y_predict = new NGrid(elements);
    }

    // destructor
    ~CorrelationResult() {
        if (y_predict != nullptr) {
            y_predict->destroy();
            y_predict = nullptr;
        }
    }

    // public variables
    NGrid* y_predict = nullptr;
    float_t x_mean = 0;
    float_t y_mean = 0;
    float_t x_variance = 0;
    float_t y_variance = 0;
    float_t x_stddev = 0;
    float_t y_stddev = 0;
    float_t y_intercept = 0;
    float_t slope = 0;
    float_t covariance = 0;
    float_t Pearson_R = 0;
    float_t r_squared = 0;
    float_t RSS = 0;
    float_t SST = 0;
    float_t SSE = 0;
    float_t SSR = 0;
    float_t MSE = 0;
    float_t MSR = 0;
};

NGrid::CorrelationResult NGrid::correlation(const NGrid& other) const {
    CorrelationResult result(this->rows);

    if (this->dimensions != 1) {
        Log::log(WARNING, "invalid usage of method NGrid::correlation(): 'this' must be a 1d array but is ", this->dimensions, "d");
        return result;
    }

    if (other.get_dimensions() != 1) {
        Log::log(WARNING, "invalid usage of method NGrid::correlation(): 'other' must be a 1d array but is ", other.get_dimensions(), "d");
        return result;
    }

    if (this->rows != other.get_rows()) {
        Log::log(WARNING, "invalid usage of method NGrid::correlation(): 'this' has ", this->elements, " elements but 'other' has ", other.get_elements(), " elements; they must be 1d arrays of equal size");
        return result;
    }

    if (this->elements == 0 || this->rows == 0 || (this->rows == 1 && this->elements > this->rows)) {
        Log::log(WARNING, "invalid usage of method NGrid::correlation(): 'this' array is empty (i.e. row elements = 0)");
        return result;
    }

    // get core values of linear correlation
    result.x_mean = this->mean();
    result.y_mean = other.mean();
    result.covariance = (*this - result.x_mean).scalar_product(other - result.y_mean) / this->elements;
    result.x_variance = this->variance();
    result.y_variance = other.variance();
    result.x_stddev = result.x_variance != 0 ? std::sqrt(result.x_variance) : float_t(NAN);
    result.y_stddev = result.y_variance != 0 ? std::sqrt(result.y_variance) : float_t(NAN);
    result.Pearson_R = result.x_stddev * result.y_stddev != 0 ? result.covariance / (result.x_stddev * result.y_stddev) : float_t(NAN);
    result.SST = this->elements * result.x_variance;
    result.slope = result.x_variance != 0 ? result.covariance / result.x_variance : float_t(NAN);
    result.y_intercept = result.y_mean - result.slope * result.x_mean;

    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("linear_predict.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.y_predict->data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.y_predict->rows, result.y_predict->cols, result.y_predict->depth });
    push_constants.add_values(result.y_intercept);
    push_constants.add_values(result.slope);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, result.y_predict->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();

    result.SSE = (*result.y_predict - result.y_mean).pow().sum();
    result.SSR = (other - *result.y_predict).pow().sum();
    result.r_squared = result.SST != 0 ? result.SSE / result.SST : NAN; //=SSE/SST, equal to 1-SSR/SST
    result.MSE = result.SSE / this->elements;

    return result;
}

// nested struct for polynomial regression
struct NGrid::RegressionResult {
public:
    // public variables
    float_t SSR = 0;
    float_t SST = 0;
    float_t SSE = 0;
    float_t MSE;
    float_t y_mean = 0;
    float_t x_mean = 0;
    float_t r_squared;
    NGrid* coefficients = nullptr;
    NGrid* y_predict = nullptr;
    NGrid* residuals = nullptr;

    bool is_good_fit(float_t threshold = 0.95) const { return r_squared > threshold; }

    std::string get_equation() const {
        std::string equation = "y = ";

        // add coefficients for powers > 1
        for (uint32_t p = power; p > 1; p--) {
            equation += std::to_string(coefficients->get(p)) + "x^" + std::to_string(p) + " + ";
        }

        // add slope = coefficient[1]
        equation += power > 0 ? std::to_string(coefficients->get(1)) + "x + " : "";

        // add error = y_intercept = coefficient[0]
        return equation + std::to_string(coefficients->get(0));
    }

    void print() const {
        std::cout
            << "=========================================================================="
            << "\nRegression Results (this=x vs. other=y):"
            << "\n   - equation: " << get_equation()
            << "\n   - mean value of x = " << x_mean
            << "\n   - mean value of y = " << y_mean
            << "\n   - coefficient of determination (r-squared) = " << r_squared
            << "\n   - total sum of squares (SST) = " << SST
            << "\n   - explained sum of squares (SSE) = " << SSE
            << "\n   - residual sum of squares (SSR) = " << SSR
            << "\n   - mean squared error (MSE) = " << MSE
            << "\n==========================================================================" << std::endl;
    }

    float_t predict(const float_t x) const {
        float_t result = 0;
        for (uint32_t p = 0; p <= power; p++) {
            result += coefficients->get(p) * std::pow(x, p);
        }
        return result;
    };

    // constructor & destructor
    RegressionResult(const uint32_t elements, const uint32_t power) : power(power) {
        if (coefficients == nullptr) {
            coefficients = new NGrid(power + 1);
        }
        if (y_predict == nullptr) {
            y_predict = new NGrid(elements);
        }
        if (residuals == nullptr) {
            residuals = new NGrid(elements);
        }
    };

    ~RegressionResult() {
        if (coefficients != nullptr) {
            delete coefficients;
        }
        if (y_predict != nullptr) {
            delete y_predict;
        }
        if (residuals != nullptr) {
            delete residuals;
        }
    }
private:
    uint32_t power;
};

// performs polynomial regression (to the specified power)
// with the source array as x and a second array
// as the corresponding y data;
// use power=1 for linear regression;
// make sure that both vectors are 1d and have the same number of
// elements
NGrid::RegressionResult NGrid::regression(const NGrid& other, const uint32_t power) const {

    RegressionResult result(this->elements, power);

    if (this->dimensions != 1) {
        Log::log(WARNING, "invalid usage of method NGrid::regression(): 'this' must be a 1d array but is ", this->dimensions, "d");
        return result;
    }

    if (other.get_dimensions() != 1) {
        Log::log(WARNING, "invalid usage of method NGrid::regression(): 'other' must be a 1d array but is ", other.get_dimensions(), "d");
        return result;
    }

    if (this->rows != other.get_rows()) {
        Log::log(WARNING, "invalid usage of method NGrid::regression(): 'this' has ", this->elements, " elements but 'other' has ", other.get_elements(), " elements; they must be 1d arrays of equal size");
        return result;
    }

    if (this->elements == 0 || this->rows == 0 || (this->rows == 1 && this->elements > this->rows)) {
        Log::log(WARNING, "invalid usage of method NGrid::regression(): 'this' array is empty (i.e. row elements = 0)");
        return result;
    }

    // Create 2d matrix of x values raised to different powers
    NGrid X(this->elements, power + 1);
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("power_matrix.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*X.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ X.rows, X.cols, X.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();

    NGrid Xt = X.transpose();
    *result.coefficients = ((Xt * X).inverse() * Xt) * other;

    // Get R-squared value and other statistics
    result.x_mean = this->mean();
    result.y_mean = other.mean();

    result.y_predict->fill(0);
    for (uint32_t p = 0; p < power; p++) {
        *result.y_predict += this->pow(p) * result.coefficients->get(p);
    }

    result.SST = this->variance() * this->elements;
    result.SSE = (*result.y_predict - result.y_mean).pow().sum();
    result.SSR = (other - *result.y_predict).pow().sum();
    result.r_squared = result.SST != 0 ? result.SSE / result.SST : NAN; //=SSE/SST, equal to 1-SSR/SST
    result.MSE = result.SSE / this->elements;

    // calculate residuals
    *result.residuals = *this - *result.y_predict;

    return result;
}

float_t NGrid::pop_last() {
    if (this->dimensions != 1) {
        Log::log(WARNING, "invalid usage of method float_t pop_last() with ", this->dimensions, " array (must be 1d)");
        return NAN;
    }
    float result = this->get(this->rows - 1);
    *this = this->erase_row(this->rows - 1);
    return result;
}

float_t NGrid::pop_first() {
    if (this->dimensions != 1) {
        Log::log(WARNING, "invalid usage of method float_t pop_first() with ", this->dimensions, " array (must be 1d)");
        return NAN;
    }
    float result = this->get(0);
    *this = this->erase_row(0);
    return result;
}

NGrid NGrid::erase_row(const uint32_t row_index) {
    if (row_index >= this->rows - 1) {
        Log::log(WARNING, "invalid usage of method 'NGrid NGrid::erase_row(const uint32_t row_index) with a row index of ",
            row_index, ": the array only has ", this->rows, " row(s); function will have no effect");
        return *this;
    }
    NGrid result(this->rows - 1, this->cols, this->depth);
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("erase_row.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(row_index);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, result.elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::erase_col(const uint32_t col_index) {
    if (col_index >= this->cols - 1) {
        Log::log(WARNING, "invalid usage of method 'NGrid NGrid::erase_col(const uint32_t col_index) with a column index of ",
            col_index, ": the array only has ", this->cols, " column(s); function will have no effect");
        NGrid result;
        result = *this;
        return result;
    }
    NGrid result(this->rows, this->cols - 1, this->depth);
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("erase_col.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(col_index);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, result.elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

NGrid NGrid::erase_layer(const uint32_t depth_layer_index) {
    if (depth_layer_index >= this->depth - 1) {
        Log::log(WARNING, "invalid usage of method 'NGrid NGrid::erase_depth(const uint32_t depth_layer_index) with a depth layer index of ",
            depth_layer_index, ": the array only has ", this->depth, " layer(s); function will have no effect");
        NGrid result;
        result = *this;
        return result;
    }
    NGrid result(this->rows, this->cols, this->depth - 1);
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("erase_depth.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(depth_layer_index);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, result.elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// performs an augmented Dickey-Fuller test
// (=unit root test for stationarity) on the sample array;
// The test returns a p-value, which is used to determine whether or not
// the null hypothesis that the dataset has a unit root
// (=implying that the sample is non-stationary and has a trend) is rejected.
// If the p-value is less than a chosen significance level (usually 0.05),
// then the null hypothesis is rejected and it is concluded that the
// time series dataset does not have a unit root and is stationary.
// The method for differencing is set to first order integer by default,
// but can be changed to other methods via the method's arguments
float_t NGrid::Dickey_Fuller() const {
    // correlate a copy of the array with a stationary transformation of itself
    NGrid copy; copy = *this;
    auto correlation_result = copy.erase_row(0).correlation(this->stationary());
    float R = correlation_result.Pearson_R;
    // calculate result
    return R * std::sqrt((float_t)(this->elements - 1) / (1 - std::pow(R, 2)));
}

// takes the source vector and another vector (passed as parameter) and
// performs an Engle-Granger test in order to test the given numeric sample
// for cointegration, i.e. checking series data for a long-term relationship.
// The test was proposed by Clive Granger and Robert Engle in 1987.
// If the returned p-value is less than a chosen significance level (typically 0.05),
// it suggests that the two time series are cointegrated and have a long-term relationship.
// Make sure that both NGrid have the same number of elements!
float_t NGrid::Engle_Granger(const NGrid& other) const {
    auto regression_result = this->stationary().regression(other.stationary());
    return regression_result.residuals->Dickey_Fuller();
}

// returns a stationary transformation of the vector data,
// using first degree differencing
// e.g. for time series data;
NGrid NGrid::stationary() const {
    NGrid result(this->rows, this->cols, this->depth);
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("stationary.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, result.elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// returns a stationary transformation of the vector data,
// using first degree logreturn differencing
// e.g. for time series data;
NGrid NGrid::stationary_log() const {
    NGrid result(this->rows, this->cols, this->depth);
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("stationary_log.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, result.elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// returns a stationary transformation of the vector data,
// using fractional differencing
// e.g. for time series data;
NGrid NGrid::stationary_fract(float_t degree, float_t exponent) const {
    NGrid result(this->rows, this->cols, this->depth);
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("stationary_fract.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });
    push_constants.add_values(degree);
    push_constants.add_values(exponent);

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, result.elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

// ascending sorting for 1d vectors
NGrid NGrid::sort() const {
    NGrid result; result = *this;
    static constexpr uint32_t workgroup_size = 256;
    static ShaderModule shader(manager->get_device());
    if (!shader.get()) { shader.read_from_file("sort.spv"); }

    static std::vector<DescriptorType> types = {
        STORAGE_BUFFER,
        STORAGE_BUFFER
    };

    DescriptorSet descriptor_set(manager->get_device(), *this->descriptor_pool, types); // set 0
    descriptor_set.bind_buffer(*this->data_buffer, 0);
    descriptor_set.bind_buffer(*result.data_buffer, 1);

    PushConstants push_constants;
    push_constants.add_values({ this->rows, this->cols, this->depth });
    push_constants.add_values({ result.rows, result.cols, result.depth });

    ComputePipeline pipeline(manager->get_device(), shader, push_constants, descriptor_set);
    command_buffer->compute(pipeline, this->elements, 1, 1, workgroup_size);
    pipeline.destroy();
    descriptor_set.destroy();
    return result;
}

float_t NGrid::covariance(const NGrid& other) const {
    return (*this - this->mean()).scalar_product(other - other.mean()) / this->elements;
}

// +=================================+   
// | Output                          |
// +=================================+

// print the vector or array to the console
// use precision argument for decimal places (use negative number for unformatted full available precision)
void NGrid::print(std::string comment, std::string delimiter, bool with_indices, bool rows_inline, int32_t precision) const {
    uint32_t decimals = std::pow(10, precision);
    std::cout << comment;
    if (comment != "") {
        std::cout << "\n";
    }

    if (this->dimensions == 1 && rows_inline) {
        for (uint32_t x = 0; x < this->rows; x++) {
            if (with_indices) {
                std::cout << "[" << x << "]=";
            }
            std::cout << this->get(x, 0, 0);
            if (x != this->rows - 1) {
                std::cout << delimiter;
            }
        }
        std::cout << "\n" << std::flush;
    }
    else {
        for (uint32_t x = 0; x < this->rows; x++) {
            for (uint32_t y = 0; y < this->cols; y++) {
                if (this->depth == 1) {
                    if (with_indices) {
                        if (this->dimensions == 1) {
                            std::cout << "[" << x << "]=";
                        }
                        else {
                            std::cout << "[" << x << "][" << y << "]=";
                        }
                    }
                    std::cout << (precision >= 0 ? std::round(this->get(x, y, 0) * decimals) / decimals : this->get(x, y, 0));
                    // add delimiter before next column
                    if (y != this->cols - 1) {
                        std::cout << delimiter;
                    }
                }
                else {
                    std::cout << "{";
                    for (uint32_t z = 0; z < this->depth; z++) {
                        if (with_indices) {
                            std::cout << "[" << x << "][" << y << "][" << z << "]=";
                        }
                        std::cout << (precision >= 0 ? std::round(this->get(x, y, z) * decimals) / decimals : this->get(x, y, z));
                        if (z != this->depth - 1) {
                            std::cout << delimiter;
                        }
                    }
                    std::cout << "}";
                    // add space before next column
                    if (y != this->cols - 1) {
                        std::cout << " ";
                    }
                }
            }
            // add line break before next row
            std::cout << "\n";
        }
        // flush to console
        std::cout << std::flush;
    }
}

// +=================================+   
// | Protected Class Members         |
// +=================================+


uint32_t NGrid::flat_index(uint32_t row, uint32_t col, uint32_t depth_layer) const {
    return  row * (this->cols * this->depth) +
            col * this->cols +
            depth_layer;
}



#endif