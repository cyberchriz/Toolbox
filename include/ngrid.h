// author and copyright: Christian Suer (cyberchriz)
// description: class for parallel floating point data structure computations on the GPU (using Vulkan)


#ifndef NGRID_H
#define NGRID_H

#define NOMINMAX
#define DEFAULT_WORKGROUP_SIZE_1D 256	// default workgroup_size_x for 1d dispatch; can be changed via set_workgroup_size_1d() method
#define DEFAULT_WORKGROUP_SIZE_2D 16	// default workgroup_size_x for 2d dispatch; can be changed via set_workgroup_size_2d() method
#define MAX_DESCRIPTOR_SET_COUNT 10 // max number of descriptor sets within the shared singleton descriptor pool

#include <__msvc_ostream.hpp>
#include <algorithm>
#include <angular.h>            // custom class for angular units
#include <bit>                  // required for bitonic sort algorithm; requires C++20
#include <cmath>
#include <cstdint>
#include <functional>
#include <initializer_list>
#include <iostream>
#include <log.h>                // custom logging class
#include <rnd.h>                // custom random number generator
#include <set>
#include <spirv_bin.h>          // source header for compute shader binaries (auto-generated by CMake + GLSL compiler (glslangValidator))
#include <stdlib.h>
#include <string>
#include <timelog.h>            // time logging functions for efficiency optimization
#include <type_traits>
#include <utility>              // for std::swap and std::move
#include <vector>
#include <vkcontext.h>          // custom high-level wrapper library for Vulkan context
#include <vulkan/vulkan.h>


// data structure class for parallel computing with Vulkan
class NGrid {
public:
	// +=================================+   
	// | Constructors & Destructors      |
	// +=================================+
	NGrid();                                        // default constructor (initilizes an empty array)
	template<typename... Args> NGrid(Args... args); // parametric default constructor for multi-dimensional array, overload for variadic template
	NGrid(const std::vector<uint32_t>& shape);      // parametric default constructor for multi-dimensional array, overload for std::vector
	NGrid(std::initializer_list<uint32_t> shape);   // parametric default constructor for multi-dimensional array, overload for std::initializer_list
	NGrid(std::vector<float_t> source_vector);      // construct 1d array and directly fill it with the contents of a std::vector<float_t>
	NGrid(const float_t* source_array, const uint32_t copied_elements, const uint32_t source_offset = 0); // construct 1d array and directly fill it with the contents of a float array[]
	NGrid(NGrid&& other) noexcept;                  // move constructor
	NGrid(const NGrid& other);                      // copy constructor
	~NGrid();                                       // destructor

	// +=================================+   
	// | Assignment                      |
	// +=================================+
	NGrid& operator=(const NGrid& other);           // copy assignment
	NGrid& operator=(NGrid&& other) noexcept;       // move assignment

	void operator=(const std::vector<float_t>& data); // alias for set(const std::vector<float_t>& data)
	void operator=(const float_t* data);            // alias for set(const float_t* data)

	// +=================================+   
	// | getters & setters               |
	// +=================================+
	void set(std::initializer_list<uint32_t> index, const float_t value);
	void set(const std::vector<uint32_t>& index, const float_t value);
	void set(const std::vector<float_t>& data, uint32_t copied_elements = 0, uint32_t source_offset_elements = 0, uint32_t target_offset_elements = 0);
	void set(const float_t* data, uint32_t copied_elements = 0, uint32_t source_offset_elements = 0, uint32_t target_offset_elements = 0);
	void set(const NGrid& other, uint32_t copied_elements = 0, uint32_t source_offset_elements = 0, uint32_t target_offset_elements = 0);
	float_t get(const uint32_t flat_index) const;
	std::vector<float_t> get() const;
	std::vector<float_t> get(const uint32_t read_elements, const uint32_t source_offset_elements) const;
	Buffer<float_t>* get_buffer() const;
	Buffer<uint32_t>* get_shape_buffer() const;
	uint32_t get_dimensions() const;
	uint32_t get_size(uint32_t dimension = 0) const;
	uint32_t get_elements() const;
	std::vector<uint32_t> get_shape() const;
	std::string get_shapestring() const;
	NGrid subgrid(std::initializer_list<uint32_t> source_offset, std::initializer_list<uint32_t> subgrid_shape) const;
	NGrid subgrid(std::vector<uint32_t> source_offset, std::vector<uint32_t> subgrid_shape) const;

	// +=================================+   
	// | Fill                            |
	// +=================================+
	void fill(const float_t value);
	void fill_zero();
	void fill_identity();
	void fill_random_gaussian(const float_t mu = 0.0f, const float_t sigma = 1.0f);
	void fill_random_uniform(const float_t min = 0.0f, const float_t max = 1.0f);
	void fill_random_uniform_int(const int32_t min = 0, const int32_t max = 9);
	void fill_random_binary(float_t ratio = 0.5f);
	void fill_random_sign(float_t ratio = 0.5f);
	void fill_range(const float_t start = 0.0f, const float_t step = 1.0f);
	void fill_dropout(float_t ratio = 0.2f);
	void fill_index();

	// +=================================+   
	// | Neural Net Weight Initialization|
	// +=================================+
	void weightinit_tanh_normal(uint32_t fan_in, uint32_t fan_out);
	void weightinit_tanh_uniform(uint32_t fan_in, uint32_t fan_out);
	void weightinit_sigmoid(uint32_t fan_in, uint32_t fan_out);
	void weightinit_relu(uint32_t fan_in);
	void weightinit_elu(uint32_t fan_in);

	// +=================================+   
	// | Distribution Properties         |
	// +=================================+
	float_t min() const;
	float_t max() const;
	float_t maxabs() const;
	float_t mean() const;
	float_t median() const;
	float_t var(bool sample_var = true) const;
	float_t stdev() const;
	float_t kurt() const;
	float_t skew() const;

	// +=================================+   
	// | Addition                        |
	// +=================================+
	float_t sum() const; // returns the sum of all array elements
	NGrid operator+(const float_t value) const;
	NGrid operator+(const NGrid& other) const;
	NGrid& operator++(); // prefix increment
	NGrid operator++(int); // postfix increment
	void operator+=(const float_t value);
	void operator+=(const NGrid& other);

	// +=================================+   
	// | Substraction                    |
	// +=================================+
	NGrid operator-(const float_t value) const;
	NGrid operator-(const NGrid& other) const;
	NGrid& operator--(); // prefix decrement
	NGrid operator--(int); // postfix decrement
	void operator-=(const float_t value);
	void operator-=(const NGrid& other);

	// +=================================+   
	// | Multiplication                  |
	// +=================================+
	float_t product() const;
	NGrid operator*(const float_t factor) const;
	void operator*=(const float_t factor);
	NGrid operator*(const NGrid& other) const;  // alias for matrix product
	void operator*=(const NGrid& other);        // "equals matrix product"
	float_t scalar_product(const NGrid& other) const;
	NGrid matrix_product(const NGrid& other) const;
	NGrid Hadamard_product(const NGrid& other) const;

	// +=================================+   
	// | Division                        |
	// +=================================+
	NGrid operator/(const float_t quotient) const;
	void operator/=(const float_t quotient);
	NGrid Hadamard_division(const NGrid& other);
	NGrid operator/(const NGrid& other) const; // alias for the matrix product with the inverse of 'other'

	// +=================================+   
	// | Modulo                          |
	// +=================================+
	void operator%=(const float_t value);
	NGrid operator%(const float_t num) const;

	// +=================================+   
	// | Exponentiation & Logarithm      |
	// +=================================+
	NGrid pow(const float_t exponent = 2.0f) const;
	NGrid operator^(const float_t exponent) const;
	void operator^=(const float_t exponent);
	NGrid pow(const NGrid& other) const;
	NGrid operator^(const NGrid& other) const;
	NGrid sqrt() const;
	NGrid log(float_t base = 2.718282) const;
	NGrid exp() const;

	// +=================================+   
	// | Rounding                        |
	// +=================================+
	NGrid round() const;
	NGrid floor() const;
	NGrid ceil() const;
	NGrid abs() const;

	// +=================================+   
	// | Min, Max                        |
	// +=================================+
	NGrid min(const float_t value) const;
	NGrid max(const float_t value) const;
	NGrid min(const NGrid& other) const;
	NGrid max(const NGrid& other) const;

	// +=================================+   
	// | Trigonometric Functions         |
	// +=================================+
	NGrid cos(AngularMeasure source_angle_unit = RAD) const;
	NGrid sin(AngularMeasure source_angle_unit = RAD) const;
	NGrid tan(AngularMeasure source_angle_unit = RAD) const;
	NGrid acos(AngularMeasure result_angle_unit = RAD) const;
	NGrid asin(AngularMeasure result_angle_unit = RAD) const;
	NGrid atan(AngularMeasure result_angle_unit = RAD) const;
	NGrid cosh() const;
	NGrid sinh() const;
	NGrid tanh() const;
	NGrid acosh() const;
	NGrid asinh() const;
	NGrid atanh() const;

	// +=================================+   
	// | Find, Replace                   |
	// +=================================+
	NGrid replace(const float_t old_value, const float_t new_value) const;
	NGrid replace_if(const NGrid& condition_map, const NGrid& replacing_map) const;
	NGrid replace_if(const NGrid& condition_map, const float_t replacing_value) const;
	uint32_t find(const float_t& value) const;
	NGrid sign() const;

	// +=================================+   
	// | Scaling                         |
	// +=================================+
	NGrid scale_minmax(float_t range_from = 0.0f, float_t range_to = 1.0f) const;
	NGrid scale_mean() const;
	NGrid scale_std() const;

	// +=================================+   
	// | Activation Functions            |
	// | (with Derivatives)              |
	// +=================================+

	// available activation functions
	enum ActFunc {
		RELU,       // rectified linear unit (ReLU)
		LRELU,      // leaky rectified linear unit (LReLU)
		ELU,        // exponential linar unit (ELU)
		LELU,       // leaky exponential linear unit
		SIGMOID,    // sigmoid (=logistic)
		TANH,       // hyperbolic tangent (tanh), with angular unit radians
		IDENT       // identity function
	};
	NGrid activation(ActFunc activation_function) const;
	NGrid derivative(ActFunc activation_function) const;

	NGrid ident() const;                                NGrid ident_drv() const;
	NGrid sigmoid() const;                              NGrid sigmoid_drv() const;
	NGrid elu(float_t alpha = 0.01) const;              NGrid elu_drv(float_t alpha = 0.01) const;
	NGrid relu(float_t alpha = 0.01) const;             NGrid relu_drv(float_t alpha = 0.01) const;
	NGrid tanh_drv() const;

	// +=================================+   
	// | Outlier Treatment               |
	// +=================================+
	NGrid clamp(const float_t min_value, const float_t max_value) const;
	NGrid outliers_truncate(float_t z_score = 3.0f) const;
	NGrid outliers_mean_imputation(float_t z_score = 3.0f) const;
	NGrid outliers_value_imputation(float_t value = 0, float_t z_score = 3.0f) const;
	NGrid recover() const;

	// +=================================+   
	// | Elementwise Comparison          |
	// +=================================+
	NGrid operator>(const float_t value) const;
	NGrid operator>=(const float_t value) const;
	NGrid operator==(const float_t value) const;
	NGrid operator!=(const float_t value) const;
	NGrid operator<(const float_t value) const;
	NGrid operator<=(const float_t value) const;
	NGrid operator>(const NGrid& other) const;
	NGrid operator>=(const NGrid& other) const;
	NGrid operator==(const NGrid& other) const;
	NGrid operator!=(const NGrid& other) const;
	NGrid operator<(const NGrid& other) const;
	NGrid operator<=(const NGrid& other) const;

	// +=================================+   
	// | Elementwise Logial Operations   |
	// +=================================+
	NGrid operator&&(const bool value) const;
	NGrid operator||(const bool value) const;
	NGrid operator!() const;
	NGrid operator&&(const NGrid& other) const;
	NGrid operator||(const NGrid& other) const;

	// +=================================+   
	// | Dynamic Handling & Conversion   |
	// +=================================+
	NGrid flatten() const;
	NGrid reshape(const std::vector<uint32_t>& new_shape, float_t default_init_value = 0) const;
	NGrid reshape(std::initializer_list<uint32_t> new_shape, float_t default_init_value = 0) const;
	NGrid concatenate(const NGrid& other, const uint32_t axis = 0) const;
	NGrid padding(const uint32_t amount, const float_t init_value = 0.0f) const;
	NGrid stationary(const uint32_t degree = 1) const;
	NGrid stationary_log(const float_t log_base = 10, const uint32_t degree = 1) const;
	NGrid sort(const bool ascending = true) const;
	NGrid pool_max(const std::vector<uint32_t>& window_shape, const std::vector<uint32_t>& stride_shape = {}) const;
	NGrid pool_max(const std::initializer_list<uint32_t>& window_shape, const std::initializer_list<uint32_t>& stride_shape = {}) const;
	NGrid pool_maxabs(const std::vector<uint32_t>& window_shape, const std::vector<uint32_t>& stride_shape = {}) const;
	NGrid pool_maxabs(const std::initializer_list<uint32_t>& window_shape, const std::initializer_list<uint32_t>& stride_shape = {}) const;
	NGrid pool_min(const std::vector<uint32_t>& window_shape, const std::vector<uint32_t>& stride_shape = {}) const;
	NGrid pool_min(const std::initializer_list<uint32_t>& window_shape, const std::initializer_list<uint32_t>& stride_shape = {}) const;
	NGrid pool_mean(const std::vector<uint32_t>& window_shape, const std::vector<uint32_t>& stride_shape = {}) const;
	NGrid pool_mean(const std::initializer_list<uint32_t>& window_shape, const std::initializer_list<uint32_t>& stride_shape = {}) const;
	NGrid convolution(const NGrid& kernel, uint32_t padding_amount = 0, float_t padding_value = 0.0f) const;
	NGrid transpose(const std::vector<uint32_t> target_axis_order = { 1,0 }) const;
	void  lu_decomp(NGrid& L, NGrid& U, NGrid& P) const;
	NGrid l_inverse() const;
	NGrid u_inverse() const;
	NGrid inverse() const;
	NGrid mirror(const std::vector<bool>& mirror_axes = {}) const;
	NGrid mirror(const std::initializer_list<bool>& mirror_axes = {}) const;
	NGrid remap(const NGrid& target_index_map) const;

	// +=================================+   
	// | Statistics                      |
	// +=================================+
	struct RegressionResult; // forward declaration
	RegressionResult regression(const NGrid& other, const bool sample = true, const uint32_t degree = 1) const;
	float_t Dickey_Fuller() const;
	float_t Engle_Granger(const NGrid& other) const;
	float_t covariance(const NGrid& other) const;

	// +=================================+   
	// | Miscellaneous                   |
	// +=================================+
	void print(std::string comment = "", std::string delimiter = "|", bool with_indices = false, bool rows_inline = true, int32_t precision = 3) const;
	static void set_workgroup_size_1d(uint32_t size);
	static void set_workgroup_size_2d(uint32_t size);
	static void set_fence_timeout_nanosec(uint64_t timeout);

protected:

	// +=================================+   
	// | Protected Class Members         |
	// +=================================+
	static VulkanManager* manager;              // shared singleton manager for instance, device and command pool
	static DescriptorPool* descriptor_pool;	    // shared singleton descriptor pool for command buffer
	static uint32_t workgroup_size_1d;          // default workgroup size for 1d dispatch
	static uint32_t workgroup_size_2d;          // default workgroup size for 2d dispatch
	static uint64_t fence_timeout_nanosec;      // timeout for waiting for the fence to be signaled
	std::vector<uint32_t> shape = {};           // shape of the array
	uint32_t dimensions = 0;                    // number of dimensions
	uint32_t elements = 0;                      // total number of elements
	CommandBuffer* command_buffer = nullptr;
	Buffer<float_t>* data_buffer = nullptr;
	Buffer<uint32_t>* shape_buffer = nullptr;

	// helper methods
	void create(const std::vector<uint32_t>& shape); // instance creation helper method, shared among constructors
	static void release_descriptor_pool();      // static method for cleanup of the shared descriptor pool
	uint32_t flat_index(std::initializer_list<uint32_t> multi_index) const;
	uint32_t flat_index(const std::vector<uint32_t>& multi_index) const;
	void copy_resources(const NGrid& other);
};


// +=================================+   
// | Static Member Initializations   |
// +=================================+
VulkanManager* NGrid::manager = nullptr;
DescriptorPool* NGrid::descriptor_pool = nullptr;
uint32_t NGrid::workgroup_size_1d = DEFAULT_WORKGROUP_SIZE_1D;
uint32_t NGrid::workgroup_size_2d = DEFAULT_WORKGROUP_SIZE_2D;
UINT64 NGrid::fence_timeout_nanosec = 1000000000; // default: 1 second timeout for waiting for the fence to be signaled




// DEFINITIONS
// ===============================================================================================================================


// +=================================+   
// | Constructors & Destructors      |
// +=================================+

// default constructor (initializes an empty array)
NGrid::NGrid() {
	std::vector<uint32_t> shape_vec = {};
	this->create(shape_vec);
}

// parametric default constructor for multi-dimensional array, overloaded for variadic template
template<typename... Args> NGrid::NGrid(Args... args) {
	std::vector<uint32_t> shape_vec = { static_cast<uint32_t>(args)... };
	this->create(shape_vec);
}

// parametric constructor for multi-dimensional array, overloaded for std::vector
NGrid::NGrid(const std::vector<uint32_t>& shape_vec) {
	this->create(shape_vec);
}

// parametric constructor for multi-dimensional array, overloaded for std::initializer_list
NGrid::NGrid(std::initializer_list<uint32_t> shape) {
	std::vector<uint32_t> shape_vec(shape);
	this->create(shape_vec);
}

// parametric constructor for 1d array:
// construct and directly fill it with the contents of a given std::vector<float_t>
NGrid::NGrid(std::vector<float_t> source_vector) {
	uint32_t copied_elements = static_cast<uint32_t>(source_vector.size());
	std::vector<uint32_t> shape_vec = { copied_elements };
	this->create(shape_vec);
	this->set(source_vector, copied_elements, 0, 0);
}
// construct 1d array and directly fill it with the contents of a given float array[]
NGrid::NGrid(const float_t* source_array, const uint32_t copied_elements, const uint32_t source_offset) {
	std::vector<uint32_t> shape_vec = { copied_elements };
	this->create(shape_vec);
	this->set(source_array, copied_elements, source_offset, 0);
}

// shared protected helper method for constructors
void NGrid::create(const std::vector<uint32_t>& shape) {
	this->shape = shape;
	this->dimensions = static_cast<uint32_t>(shape.size());

	// count the number of array elements
	if (dimensions == 0) {
		elements = 0;
	}
	else {
		elements = 1;
		for (uint32_t i = 0; i < shape.size(); ++i) {
			elements *= this->shape[i];
		}
	}

	// create a shared manager for instance, device and commandpool
	if (VulkanManager::get_singleton() == nullptr) {
		manager = VulkanManager::make_singleton_for_compute(1, 3, 0);
	}
	else {
		manager = VulkanManager::get_singleton();
	}

	// create a descriptor pool for the command buffer
	if (descriptor_pool == nullptr) {
		std::vector<VkDescriptorPoolSize> max_buffers = {
			{VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 20},
			{VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 20}
		};
		descriptor_pool = new DescriptorPool(manager->get_device(), MAX_DESCRIPTOR_SET_COUNT, max_buffers);

		// register static destructor for cleanup at program termination;
		// note: this is necessary because descriptor_pool is a static object shared across multiple instances of NGrid,
		// therefore it shouldn't be destroyed by any object destructors which are meant for single instances
		std::atexit(&NGrid::release_descriptor_pool);
	}

	// create a command buffer
	if (this->command_buffer == nullptr) {
		command_buffer = new CommandBuffer(manager->get_device(), QueueFamily::COMPUTE_QUEUE, manager->get_command_pool_compute());
	}

	if (this->elements != 0) {
		// allocate as a 'flat' buffer -> this is required because GLSL shaders only support dynamic sizing in a single (=the last) dimension
		VkMemoryPropertyFlags memory_properties = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
		if (this->data_buffer == nullptr) {
			data_buffer = new Buffer<float_t>(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->elements, memory_properties);
		}
		else {
			// keep the previous buffer only if it already has sufficient capacity
			if (data_buffer->get_elements() < this->elements) {
				delete data_buffer;
				data_buffer = new Buffer<float_t>(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->elements, memory_properties);
			}
		}

		// allocate a storage buffer for the shape of the array
		if (this->shape_buffer == nullptr) {
			shape_buffer = new Buffer<uint32_t>(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions, memory_properties);
		}
		else {
			// if it already exists: create a new one in case the number of dimensions is wrong
			if (shape_buffer->get_elements() != this->dimensions) {
				delete shape_buffer;
				shape_buffer = new Buffer<uint32_t>(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions, memory_properties);
			}
		}
		shape_buffer->write(this->shape, this->dimensions, 0, 0);
	}
}

// move constructor
NGrid::NGrid(NGrid&& other) noexcept {
	Log::debug("NGrid move constructor invoked");
	this->elements = other.elements;                            other.elements = 0;
	this->dimensions = other.dimensions;                        other.dimensions = 0;
	this->shape = std::move(other.shape);                       other.shape.clear();
	if (this->data_buffer != nullptr) {
		delete[] this->data_buffer;
	}
	this->data_buffer = std::move(other.data_buffer);           other.data_buffer = nullptr;
	this->shape_buffer = std::move(other.shape_buffer);         other.shape_buffer = nullptr;
	this->command_buffer = std::move(other.command_buffer);		other.command_buffer = nullptr;
}

// copy constructor
NGrid::NGrid(const NGrid& other) {
	Log::debug("NGrid copy constructor invoked");
	this->create(other.get_shape());
	this->set(other);
}

// destructor
NGrid::~NGrid() {
	// destroy in reverse order of creation
	Log::debug("NGrid destructor invoked");
	if (this->shape_buffer != nullptr) {
		delete this->shape_buffer;
		this->shape_buffer = nullptr;
	}
	if (this->data_buffer != nullptr) {
		delete this->data_buffer;
		this->data_buffer = nullptr;
	}
	if (this->command_buffer != nullptr) {
		delete this->command_buffer;
		this->command_buffer = nullptr;
	}
	// Note: 'manager' and 'descriptor_pool' are static objects, shared across multiple instances of NGrid,
	// therefore they shouldn't be destroyed by any object destructors which are meant for single instances
}

// +=================================+   
// | Assignment                      |
// +=================================+

// copy assignment operator
NGrid& NGrid::operator=(const NGrid& other) {
	Log::debug("NGrid copy assignment invoked, copying from other (handle: ", other.data_buffer, ") to this (handle: ", this->data_buffer, ")");
	if (this != &other) {
		delete this->data_buffer;
		delete this->shape_buffer;
		this->create(other.get_shape());
		this->set(other);
	}
	return *this;
}

// move assignment operator
NGrid& NGrid::operator=(NGrid&& other) noexcept {
	Log::debug("NGrid move assignment invoked, moving from other (handle: ", other.data_buffer, ") to this (handle: ", this->data_buffer, ")");
	if (this != &other) {
		this->elements = other.elements;                            other.elements = 0;
		this->dimensions = other.dimensions;                        other.dimensions = 0;
		this->shape = std::move(other.shape);                       other.shape.clear();
		delete this->data_buffer;
		delete this->shape_buffer;
		delete this->command_buffer;
		this->data_buffer = std::move(other.data_buffer);           other.data_buffer = nullptr;
		this->shape_buffer = std::move(other.shape_buffer);         other.shape_buffer = nullptr;
		this->command_buffer = std::move(other.command_buffer);		other.command_buffer = nullptr;
	}
	return *this;
}

// +=================================+   
// | getters & setters               |
// +=================================+

// assigns a value to a data element via multi-dimensional index;
// overload with index as std::initializer_list<uint32_t>
void NGrid::set(std::initializer_list<uint32_t> index, const float_t value) {
	this->data_buffer->write_element(flat_index(index), value);
}

// assigns a value to a data element via multi-dimensional index;
// overload with index as std::vector<uint32_t>
void NGrid::set(const std::vector<uint32_t>& index, const float_t value) {
	this->data_buffer->write_element(flat_index(index), value);
}

// alias for set(const std::vector<float_t>& data)
void NGrid::operator=(const std::vector<float_t>& data) {
	this->set(data);
}

// alias for set(const float_t* data)
void NGrid::operator=(const float_t* data) {
	this->set(data, this->elements);
}

// copies raw data from a std::vector<float_t> to the data buffer
// of the underlying NGrid array;
// copied_elements=0 means: copy ALL elements from the source buffer
void NGrid::set(const std::vector<float_t>& data, uint32_t copied_elements, uint32_t source_offset_elements, uint32_t target_offset_elements) {
	data_buffer->write(data, copied_elements, source_offset_elements, target_offset_elements);
}

// copies raw data from a float_t array to the data buffer
// of the underlying NGrid array;
void NGrid::set(const float_t* data, uint32_t copied_elements, uint32_t source_offset_elements, uint32_t target_offset_elements) {
	data_buffer->write(data, copied_elements, source_offset_elements, target_offset_elements);
}

// copies raw data from another NGrid array to the data buffer
// of the underlying NGrid array;
// flat indexing is used for the offset, i.e. making use of
// offset parameters mostly makes sense for 1d arrays;
// if arguments for copied_elements and offsets aren't used this method will also
// work to copy multi-dimensional arrays (copy assignment may be used alternatively)
void NGrid::set(const NGrid& other, uint32_t copied_elements, uint32_t source_offset_elements, uint32_t target_offset_elements) {
	// make sure 'other' is not empty
	if (other.get_elements() == 0) {
		Log::warning("attempt to use method NGrid::set(const NGrid& other, ...) with empty 'other' array");
		return;
	}
	// make sure 'this' has a buffer with size >0
	if (this->elements == 0) {
		if (copied_elements == 0) {
			if (other.get_dimensions() == 1) {
				std::vector<uint32_t> new_shape = { target_offset_elements + other.get_elements() };
				this->create(new_shape);
			}
			else {
				this->create(other.get_shape());
			}
		}
		else {
			if (other.get_dimensions() == 1) {
				std::vector<uint32_t> new_shape = { target_offset_elements + copied_elements };
				this->create(new_shape);
			}
			else {
				this->create(other.get_shape());
			}
		}
	}
	data_buffer->write(*other.get_buffer(), copied_elements, source_offset_elements, target_offset_elements);
}

// returns the value of an array element via its flattened index
float_t NGrid::get(const uint32_t flat_index) const {
	// using flat index as 'row' index
	return data_buffer->read_element(flat_index);
}

// returns a flat (= 1-dimensional) copy of ALL raw data of the underlying buffer as type std::vector<float_t>
std::vector<float> NGrid::get() const {
	return data_buffer->read();
}

// returns a flat (= 1-dimensional) copy of the raw data of the underlying buffer as type std::vector<float_t>;
// this overload uses parameters "read_elements" and "source_offset_elements" to allow copying only a subset of the data
std::vector<float> NGrid::get(const uint32_t read_elements, const uint32_t source_offset_elements) const {
	return data_buffer->read(read_elements, source_offset_elements);
}

// returns the buffer containg the raw array data
Buffer<float_t>* NGrid::get_buffer() const {
	return this->data_buffer;
}

// returns the buffer containg the shape of the array
Buffer<uint32_t>* NGrid::get_shape_buffer() const {
	return this->shape_buffer;
}

// returns the number of dimensions of the underlying array
uint32_t NGrid::get_dimensions() const {
	return this->dimensions;
}

// returns the number of rows, i.e. the size of the 'first' dimension (indexing starts from 0)
uint32_t NGrid::get_size(uint32_t dimension) const {
	if (dimension >= this->dimensions) {
		Log::error("invalid usage of method 'NGrid get_size(uint32_t dimension)' with invalid dimension index; index is ",
			dimension, ", the underlying array has ", this->dimensions, " dimension(s); dimension indexing starts from 0, with a maximum of ",
			this->dimensions - 1);
	}
	else {
		return shape[dimension];
	}
}

// returns the total number of elements of the underlying array, i.e. across all dimensions
uint32_t NGrid::get_elements() const {
	return this->elements;
}

// returns the shape of the array as std::vector<uint32_t>
std::vector<uint32_t> NGrid::get_shape() const {
	return this->shape;
}

// returns the shape of the array as std::string
std::string NGrid::get_shapestring() const {
	std::string result = "{";
	for (uint32_t i = 0; i < this->dimensions; i++) {
		result += std::to_string(this->shape[i]);
		if (i < this->dimensions - 1) { result += ","; }
	}
	result += "}";
	return result;
}

// slice a subarray out of the parent array
NGrid NGrid::subgrid(std::initializer_list<uint32_t> source_offset, std::initializer_list<uint32_t> subgrid_shape) const {
	// convert the initializer_lists to vectors
	std::vector<uint32_t> source_offset_vector = source_offset;
	std::vector<uint32_t> subgrid_shape_vector = subgrid_shape;

	// check if the source and result dimensions are equal
	uint32_t subgrid_dimensions = static_cast<uint32_t>(subgrid_shape.size());
	if (subgrid_dimensions != this->dimensions) {
		Log::error("invalid usage of method 'NGrid subgrid(std::initializer_list<uint32_t> source_offset, std::initializer_list<uint32_t> subgrid_shape)' ",
			"with invalid subgrid_shape, which has ", subgrid_dimensions, " dimension(s), but the source array has ", this->dimensions, " dimension(s)");
	}
	for (uint32_t i = 0; i < subgrid_dimensions; i++) {
		if (subgrid_shape_vector[i] > this->shape[i] - source_offset_vector[i]) {
			Log::error("invalid usage of method 'NGrid subgrid(std::initializer_list<uint32_t> source_offset, std::initializer_list<uint32_t> result_size)' with invalid result size; ",
				"result size is ", subgrid_shape_vector[i], ", but the underlying array has ", this->shape[i], " element(s) in dimension ", i, ", therefore with a source offset of ",
				source_offset_vector[i], " the result size in this dimensions can't exceed ", shape[i] - subgrid_shape_vector[i]);
		}
	}
	NGrid subgrid(subgrid_shape);

	Buffer<uint32_t> source_offset_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions);
	source_offset_buffer.write(source_offset);

	static ShaderModule shader(manager->get_device(), SUBGRID_SPIRV_BIN, SUBGRID_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*subgrid.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*subgrid.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(source_offset_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions);
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, subgrid.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
	return subgrid;
}

NGrid NGrid::subgrid(std::vector<uint32_t> source_offset, std::vector<uint32_t> subgrid_shape) const {
	// check if the source and result dimensions are equal
	uint32_t subgrid_dimensions = static_cast<uint32_t>(subgrid_shape.size());
	if (subgrid_dimensions != this->dimensions) {
		Log::error("invalid usage of method 'NGrid subgrid(std::initializer_list<uint32_t> source_offset, std::initializer_list<uint32_t> subgrid_shape)' ",
			"with invalid subgrid_shape, which has ", subgrid_dimensions, " dimension(s), but the source array has ", this->dimensions, " dimension(s)");
	}
	for (uint32_t i = 0; i < subgrid_dimensions; i++) {
		if (subgrid_shape[i] > this->shape[i] - source_offset[i]) {
			Log::error("invalid usage of method 'NGrid subgrid(std::initializer_list<uint32_t> source_offset, std::initializer_list<uint32_t> result_size)' with invalid result size; ",
				"result size is ", subgrid_shape[i], ", but the underlying array has ", this->shape[i], " element(s) in dimension ", i, ", therefore with a source offset of ",
				source_offset[i], " the result size in this dimensions can't exceed ", shape[i] - subgrid_shape[i]);
		}
	}
	NGrid subgrid(subgrid_shape);

	Buffer<uint32_t> source_offset_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions);
	source_offset_buffer.write(source_offset);

	static ShaderModule shader(manager->get_device(), SUBGRID_SPIRV_BIN, SUBGRID_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*subgrid.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*subgrid.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(source_offset_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions, subgrid.get_elements());
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, subgrid.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
	return subgrid;
}

// +=================================+   
// | Fill, Initialize                |
// +=================================+

// fill entire array with given floating point value
void NGrid::fill(const float_t value) {
	static ShaderModule shader(manager->get_device(), FILL_SPIRV_BIN, FILL_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// initialize the entire array with zeros
void NGrid::fill_zero() {
	static ShaderModule shader(manager->get_device(), FILL_ZERO_SPIRV_BIN, FILL_ZERO_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill entire array with identity matrix
void NGrid::fill_identity() {
	static ShaderModule shader(manager->get_device(), FILL_IDENTITY_SPIRV_BIN, FILL_IDENTITY_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, this->dimensions);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill with values from a random normal (=gaussian) distribution
void NGrid::fill_random_gaussian(const float_t mu, const float_t sigma) {
	static ShaderModule shader(manager->get_device(), FILL_RANDOM_GAUSSIAN_SPIRV_BIN, FILL_RANDOM_GAUSSIAN_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, rnd::seed32(), mu, sigma);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill with values from a random uniform distribution
void NGrid::fill_random_uniform(const float_t min, const float_t max) {
	static ShaderModule shader(manager->get_device(), FILL_RANDOM_UNIFORM_SPIRV_BIN, FILL_RANDOM_UNIFORM_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());

	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, rnd::seed32(), min, max);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill with values from a random uniform distribution
void NGrid::fill_random_uniform_int(const int32_t min, const int32_t max) {
	static ShaderModule shader(manager->get_device(), FILL_RANDOM_UNIFORM_INT_SPIRV_BIN, FILL_RANDOM_UNIFORM_INT_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, rnd::seed32(), min, max);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// randomly sets the specified fraction of the values to zero and the rest to 1 (default: 0.5, i.e. 50%)
void NGrid::fill_random_binary(float_t ratio) {
	// check valid ratio
	if (ratio > 1 || ratio < 0) {
		Log::warning("invalid usage of method 'void NGrid::fill_binary(float_t ratio)': ratio argument must be between 0-1 but is ",
			ratio, " --> argument will be clipped to fit this range");
	}
	float_t valid_ratio = std::fmax(std::fmin(ratio, 1.0f), 0.0f);

	static ShaderModule shader(manager->get_device(), FILL_RANDOM_BINARY_SPIRV_BIN, FILL_RANDOM_BINARY_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, rnd::seed32(), valid_ratio);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// randomly sets the specified fraction of the values to -1 and the rest to +1 (default: 0.5, i.e. 50%)
void NGrid::fill_random_sign(float_t ratio) {
	// check valid ratio
	if (ratio > 1 || ratio < 0) {
		Log::warning("invalid usage of method 'void NGrid::fill_binary(float_t ratio)': ratio argument must be between 0-1 but is ",
			ratio, " --> argument will be clipped to fit this range");
	}
	float_t valid_ratio = std::fmax(std::fmin(ratio, 1.0f), 0.0f);

	static ShaderModule shader(manager->get_device(), FILL_RANDOM_SIGN_SPIRV_BIN, FILL_RANDOM_SIGN_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, rnd::seed32(), valid_ratio);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fills the array with a continuous
// range of numbers (with specified start parameter
// referring to the zero position and a step parameter)
// in all dimensions
void NGrid::fill_range(const float_t start, const float_t step) {
	static ShaderModule shader(manager->get_device(), FILL_RANGE_SPIRV_BIN, FILL_RANGE_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, this->dimensions, start, step);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

void NGrid::fill_dropout(float_t ratio) {
	// check valid ratio
	if (ratio > 1 || ratio < 0) {
		Log::warning("invalid usage of method 'void NGrid::fill_dropout(float_t ratio)': ratio argument must be between 0-1 but is ",
			ratio, " --> argument will be clipped to fit this range");
	}
	float_t valid_ratio = std::fmax(std::fmin(ratio, 1.0f), 0.0f);

	static ShaderModule shader(manager->get_device(), FILL_DROPOUT_SPIRV_BIN, FILL_DROPOUT_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, valid_ratio, rnd::seed32());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill with normal "Xavier" weight initialization
// (by Xavier Glorot & Bengio) for tanh activation
void NGrid::weightinit_tanh_normal(uint32_t fan_in, uint32_t fan_out) {
	static ShaderModule shader(manager->get_device(), WEIGHTINIT_TANH_NORMAL_SPIRV_BIN, WEIGHTINIT_TANH_NORMAL_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, fan_in, fan_out, rnd::seed32());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill with uniform "Xavier" weight initializiation
// (by Xavier Glorot & Bengio), e.g. for tanh activation
void NGrid::weightinit_tanh_uniform(uint32_t fan_in, uint32_t fan_out) {
	static ShaderModule shader(manager->get_device(), WEIGHTINIT_TANH_UNIFORM_SPIRV_BIN, WEIGHTINIT_TANH_UNIFORM_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, fan_in, fan_out, rnd::seed32());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill with uniform "Xavier" weight initialization
// for sigmoid activation
void NGrid::weightinit_sigmoid(uint32_t fan_in, uint32_t fan_out) {
	static ShaderModule shader(manager->get_device(), WEIGHTINIT_SIGMOID_SPIRV_BIN, WEIGHTINIT_SIGMOID_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, fan_in, fan_out, rnd::seed32());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill with "Kaiming He" normal weight initialization,
// used for ReLU activation
void NGrid::weightinit_relu(uint32_t fan_in) {
	static ShaderModule shader(manager->get_device(), WEIGHTINIT_RELU_SPIRV_BIN, WEIGHTINIT_RELU_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, fan_in, rnd::seed32());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fill with modified "Kaiming He" nornal weight initialization,
// used for ELU activation
void NGrid::weightinit_elu(uint32_t fan_in) {
	static ShaderModule shader(manager->get_device(), WEIGHTINIT_ELU_SPIRV_BIN, WEIGHTINIT_ELU_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, fan_in, rnd::seed32());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// fills the array elements with their flat indices
void NGrid::fill_index() {
	static ShaderModule shader(manager->get_device(), FILL_INDEX_SPIRV_BIN, FILL_INDEX_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
}

// +=================================+
// | Distribution Properties         |
// +=================================+

// returns the lowest value of the NGrid,
// across all dimensions
float_t NGrid::min() const {
	static ShaderModule shader(manager->get_device(), MIN_SPIRV_BIN, MIN_SPIRV_BYTES);

	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return local_results.read_element(0);
}

// returns the highest value of the NGrid,
// across all dimensions
float_t NGrid::max() const {
	static ShaderModule shader(manager->get_device(), MAX_SPIRV_BIN, MAX_SPIRV_BYTES);

	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return local_results.read_element(0);
}

// returns the value of the NGrid with the highest
// deviation from zero, across all dimensions
float_t NGrid::maxabs() const {
	static ShaderModule shader(manager->get_device(), MAXABS_SPIRV_BIN, MAXABS_SPIRV_BYTES);

	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return local_results.read_element(0);
}

// returns the arrithmetic mean of all values of the NGrid
float_t NGrid::mean() const {
	return this->sum() / this->elements;
}

// returns the median of all values the NGrid;
// NGrid must be 1d
float_t NGrid::median() const {

	// confirm 1d array
	if (this->dimensions > 1) {
		Log::warning("invalid usage of method NGrid::median(), underlying array must be 1d but has ", this->dimensions, " dimensions");
		return 0.0f;
	}

	NGrid sorted = this->sort();

	// odd number of elements
	if (this->elements % 2) {
		return sorted.get(elements / 2);
	}
	// even number of elements
	else {
		return (sorted.get(elements / 2 - 1) + sorted.get(elements / 2)) / 2;
	}
}

// returns the variance of all values of a vector, matrix or array
// as a floating point number;
// use 'true' for the sample_var parameter to query the sample variance;
// if 'false' the population variance will be returned instead
float_t NGrid::var(bool sample_var) const {
	// std::cout << "expected variance result: " << (this->operator-((this->operator/(elements)).sum())).pow().operator/(elements - 1).sum() << std::endl;
	static ShaderModule shader(manager->get_device(), VARIANCE_SPIRV_BIN, VARIANCE_SPIRV_BYTES);

	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, static_cast<uint32_t>(sample_var));

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return local_results.read_element(0);
}

// returns the standard deviation of all values a the vector, matrix or array
float_t NGrid::stdev() const {
	return std::sqrt(this->var());
}

// returns the sample skewness of all data of the NGrid
float_t NGrid::skew() const {
	static ShaderModule shader(manager->get_device(), SKEW_SPIRV_BIN, SKEW_SPIRV_BYTES);

	Buffer<float> local_results1(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));
	Buffer<float> local_results2(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results1, DescriptorType::STORAGE_BUFFER_DESCRIPTOR); // local_result1[0] will store the mean mdev2
	set.bind_buffer(local_results2, DescriptorType::STORAGE_BUFFER_DESCRIPTOR); // local_result1[0] will store the mean mdev3
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return static_cast<float_t>(local_results1.read_element(0) / std::pow(local_results2.read_element(0), 1.5));
}

// returns the sample kurtosis of all elements of the NGrid
float_t NGrid::kurt() const {
	static ShaderModule shader(manager->get_device(), SKEW_SPIRV_BIN, SKEW_SPIRV_BYTES);

	Buffer<float> local_results1(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));
	Buffer<float> local_results2(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results1, DescriptorType::STORAGE_BUFFER_DESCRIPTOR); // local_result1[0] will store the mean mdev2
	set.bind_buffer(local_results2, DescriptorType::STORAGE_BUFFER_DESCRIPTOR); // local_result2[0] will store the mean mdev4
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	float_t mean_mdev2 = local_results1.read_element(0);
	float_t mean_mdev4 = local_results2.read_element(0);
	return mean_mdev4 / (mean_mdev2 * mean_mdev2) - 3;
}

// +=================================+   
// | Addition                        |
// +=================================+

// returns the sum of all array elements;
float_t NGrid::sum() const {
	static ShaderModule shader(manager->get_device(), SUM_SPIRV_BIN, SUM_SPIRV_BYTES);

	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return local_results.read_element(0);
}

// elementwise addition of the specified value to all elements of the array
NGrid NGrid::operator+(const float_t value) const {

	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), OPERATOR_PLUS_SPIRV_BIN, OPERATOR_PLUS_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// returns the resulting array of the elementwise addition of two arrays
NGrid NGrid::operator+(const NGrid& other) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), OPERATOR_PLUS_OTHER_SPIRV_BIN, OPERATOR_PLUS_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions, other.get_dimensions(), this->elements, other.get_elements());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// prefix increment operator;
// increments the values of the array by +1,
// returns a reference to the source array itself
NGrid& NGrid::operator++() {
	*this += 1.0f;
	return *this;
}

// postfix increment operator;
// makes an internal copy of the array,
// then increments all values of the array by +1,
// then returns the temporary copy;
// note: more overhead then with the prefix increment
// because of extra copy!
NGrid NGrid::operator++(int) {
	NGrid result = *this;
	*this += 1.0f;
	return result;
}

// elementwise addition of the specified
// value to the elements of the array
void NGrid::operator+=(const float_t value) {
	*this = this->operator+(value);
}

// elementwise addition of the values of 'other'
// to the values of the corresponding elements of 'this'
void NGrid::operator+=(const NGrid& other) {
	*this = this->operator+(other);
}


// +=================================+   
// | Substraction                    |
// +=================================+

// elementwise substraction of the specified value from all values of the array
NGrid NGrid::operator-(const float_t value) const {
	// using the member method "NGrid operator+(const float_t value) const"
	return this->operator+(value * -1);
}

// returns the resulting array of the elementwise substraction of
// two array of equal dimensions
NGrid NGrid::operator-(const NGrid& other) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), OPERATOR_MINUS_OTHER_SPIRV_BIN, OPERATOR_MINUS_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions, other.get_dimensions(), this->elements, other.get_elements());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// prefix decrement operator;
// decrements the values of the array by -1
NGrid& NGrid::operator--() {
	*this = *this + (-1.0f);
	return *this;
}

// postfix decrement operator;
// makes an internal copy of the array,
// then decrements all values of the array by -1,
// then returns the temporary copy;
// note: more overhead then with the prefix decrement
// because of extra copy!
NGrid NGrid::operator--(int) {
	NGrid result = *this;
	*this += (-1.0f);
	return result;
}

// elementwise substraction of the specified
// value from the elements of the array
void NGrid::operator-=(const float_t value) {
	*this = *this + (value * -1);
}

// elementwise substraction of the values of 'other'
// from the values of the corresponding elements of 'this'
void NGrid::operator-=(const NGrid& other) {
	*this = this->operator-(other);
}

// +=================================+   
// | Multiplication                  |
// +=================================+

// returns the product reduction, i.e. the result
// of multiplication all individual elements of the array
float_t NGrid::product() const {
	static ShaderModule shader(manager->get_device(), PRODUCT_SPIRV_BIN, PRODUCT_SPIRV_BYTES);

	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return local_results.read_element(0);
}

// elementwise multiplication with a scalar
NGrid NGrid::operator*(const float_t factor) const {

	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), OPERATOR_MULTIPLY_SPIRV_BIN, OPERATOR_MULTIPLY_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, factor);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise multiplication (*=) with a scalar
void NGrid::operator*=(const float_t factor) {
	*this = this->operator*(factor);
}

// Alias for 2D or 3D matrix multiplication
NGrid NGrid::operator*(const NGrid& other) const {
	return this->matrix_product(other);
}

// Alias for 2D or 3D matrix multiplication;
// note: 'this' is getting reassigned and may change its shape as a consequence of this operation
void NGrid::operator*=(const NGrid& other) {
	*this = this->matrix_product(other);
}

// scalar product
float_t NGrid::scalar_product(const NGrid& other) const {
	return this->Hadamard_product(other).sum();
}

// 2D matrix product
NGrid NGrid::matrix_product(const NGrid& other) const {
	if (this->dimensions > 2 || this->dimensions == 0 || other.get_dimensions() > 2 || other.get_dimensions() == 0) {
		Log::error("invalid call of NGrid::matrix_product; first array has shape ", this->get_shapestring(), ", second array has shape ",
			other.get_shapestring(), "; both arrays must be 1d or 2d");
	}
	static ShaderModule shader(manager->get_device(), MATRIX_PRODUCT_OTHER_SPIRV_BIN, MATRIX_PRODUCT_OTHER_SPIRV_BYTES);

	uint32_t first_rows = this->shape[0];
	uint32_t first_cols = this->dimensions == 1 ? 1 : this->shape[1];
	uint32_t second_rows = other.get_dimensions() == 1 ? 1 : other.get_shape()[0];
	uint32_t second_cols = other.get_dimensions() == 1 ? other.get_shape()[0] : other.get_shape()[1];
	uint32_t result_rows = first_rows;
	uint32_t result_cols = second_cols;

	if (first_cols != second_rows) {
		Log::error("invalid call of NGrid::matrix_product; the 'inner' dimensions must match! First array A{m,n} has shape ",
			this->get_shapestring(), ", second array B{o,p} has shape ", other.get_shapestring(), ", i.e. n!=p, result is undefined");
	}

	// set result array with correct dimensions
	// the matrix product of A{m,n} and B{n,p} has shape AxB=C{m,p}
	NGrid result({ result_rows, result_cols });

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(
		this->elements,
		first_rows,
		first_cols,
		other.get_elements(),
		second_rows,
		second_cols,
		result.get_elements(),
		result_rows,
		result_cols
	);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d, 1, 1);
	command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise multiplication of the values of the current
// array with the corresponding values of a second array,
// resulting in the 'Hadamard product';
// the dimensions of the two arrays must match!
// if they don't: only the common elements will be part of the result array
NGrid NGrid::Hadamard_product(const NGrid& other) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), HADAMARD_PRODUCT_OTHER_SPIRV_BIN, HADAMARD_PRODUCT_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions, other.get_dimensions(), this->elements, other.get_elements());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Division                        |
// +=================================+

// elementwise division by a scalar
NGrid NGrid::operator/(const float_t quotient) const {
	if (quotient == 0) {
		Log::error("invalid call of method 'NGrid NGrid::operator/(const T quotient)' with quotient=0 (zero division is undefined)");
	}
	return (*this) * (1.0f / quotient);
}

// elementwise division (/=) by a scalar
void NGrid::operator/=(const float_t quotient) {
	(*this) *= (1.0f / quotient);
}

// elementwise division of the values of the current
// array by the corresponding values of a second NGrid,
// resulting in the 'Hadamard division';
// the dimensions of the two arrays must match!
NGrid NGrid::Hadamard_division(const NGrid& other) {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), HADAMARD_DIVISION_OTHER_SPIRV_BIN, HADAMARD_DIVISION_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions, other.get_dimensions(), this->elements, other.get_elements());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// matrix division of the NGrids;
// this is an alias for the matrix product of 'this' with the inverse of 'other'
NGrid NGrid::operator/(const NGrid& other) const {
	return *this * other.inverse();
}

// +=================================+   
// | Modulo                          |
// +=================================+

// elementwise modulo operation, converting the NGrid values
// to the remainders of their division by the specified number
void NGrid::operator%=(const float_t value) {
	*this = this->operator%(value);
}

// elementwise modulo operation, resulting in an NGrid array that
// contains the remainders of the division of the values of
// the original array by the specified number
NGrid NGrid::operator%(const float_t value) const {

	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), OPERATOR_MODULO_SPIRV_BIN, OPERATOR_MODULO_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Exponentiation & Logarithm      |
// +=================================+

// elementwise exponentiation to the power of
// the specified exponent
NGrid NGrid::pow(const float_t exponent) const {

	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), POW_SPIRV_BIN, POW_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, exponent);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// alias for pow(exponent):
// elementwise exponentiation to the power of
// the specified exponent
NGrid NGrid::operator^(const float_t exponent) const {
	return this->pow(exponent);
}

// alias for pow(other):
// elementwise exponentiation to the power of
// the corresponding element of 'other'
NGrid NGrid::operator^(const NGrid& other) const {
	return this->pow(other);
}

// elementwise exponentiation of the values of 'this'
// to the power of the specified exponent
void NGrid::operator^=(const float_t exponent) {
	*this = this->pow(exponent);
}

// elementwise exponentiation to the power of
// the corresponding values of the second array;
// the dimensions of the two array must match!
NGrid NGrid::pow(const NGrid& other) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), POW_OTHER_SPIRV_BIN, POW_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions, other.get_dimensions(), this->elements, other.get_elements());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// converts the individual values of the array
// elementwise to their square root
NGrid NGrid::sqrt() const {
	return this->pow(0.5f);
}

NGrid NGrid::log(float_t base) const {
	if (base <= 0) {
		Log::error("invalid call of NGrid::log with base ", base, ", argument can't be <= 0, result is undefined)");
	}
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), LOG_SPIRV_BIN, LOG_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, base);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::exp() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), EXP_SPIRV_BIN, EXP_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Rounding                        |
// +=================================+

// rounds the values of the array elementwise
// to their nearest integers
NGrid NGrid::round() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), ROUND_SPIRV_BIN, ROUND_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// rounds the values of the array elementwise
// to their next lower integers
NGrid NGrid::floor() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), FLOOR_SPIRV_BIN, FLOOR_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// returns a copy of the array that stores the values as rounded
// to their next higher integers
NGrid NGrid::ceil() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), CEIL_SPIRV_BIN, CEIL_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// returns a copy of the array that stores the
// absolute values of the source array
NGrid NGrid::abs() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), ABS_SPIRV_BIN, ABS_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// returns a copy of the array that stores the
// values of the source array clamped in the range between a min and max value
NGrid NGrid::clamp(const float_t min_value, const float_t max_value) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), CLAMP_SPIRV_BIN, CLAMP_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, min_value, max_value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Min, Max                        |
// +=================================+

// elementwise minimum of the specified value
// and the data elements of the array
NGrid NGrid::min(const float_t value) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), MIN_VALUE_SPIRV_BIN, MIN_VALUE_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise maximum of the specified value
// and the data elements of the array
NGrid NGrid::max(const float_t value) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), MAX_VALUE_SPIRV_BIN, MAX_VALUE_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// returns the result of elementwise min() comparison
// of 'this' vs 'other'
NGrid NGrid::min(const NGrid& other) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), MIN_OTHER_SPIRV_BIN, MIN_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions, other.get_dimensions(), this->elements, other.get_elements());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// returns the result of elementwise max() comparison
// of 'this' vs 'other'
NGrid NGrid::max(const NGrid& other) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), MAX_OTHER_SPIRV_BIN, MAX_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->dimensions, other.get_dimensions(), this->elements, other.get_elements());

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Trigonometric Functions         |
// +=================================+

// elementwise application of the cos() function;
// the result is a dimensionless ratio (adjacent / hypotenuse)
NGrid NGrid::cos(AngularMeasure source_angle_unit) const {
	float_t factor = static_cast<float_t>(convert_angle(1.0f, source_angle_unit, RAD));
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), COS_SPIRV_BIN, COS_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, factor);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the sin() function;
// the result is a dimensionless ratio (opposite / hypotenuse)
NGrid NGrid::sin(AngularMeasure source_angle_unit) const {
	float_t factor = static_cast<float_t>(convert_angle(1.0f, source_angle_unit, RAD));
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), SIN_SPIRV_BIN, SIN_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, factor);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the tan function;
// the result is a dimensionless ratio (opposite / adjacent)
NGrid NGrid::tan(AngularMeasure source_angle_unit) const {
	float_t factor = static_cast<float_t>(convert_angle(1.0f, source_angle_unit, RAD));
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), TAN_SPIRV_BIN, TAN_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, factor);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the acos() function;
// inverse function of cos(), i.e. returns the angle
// whose cosine equals a given value
NGrid NGrid::acos(AngularMeasure result_angle_unit) const {
	float_t factor = static_cast<float_t>(convert_angle(1.0f, RAD, result_angle_unit));
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), ACOS_SPIRV_BIN, ACOS_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, factor);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the asin() function;
// inverse function of sin(), i.e. returns the angle
// whose sine equals a given value
NGrid NGrid::asin(AngularMeasure result_angle_unit) const {
	float_t factor = static_cast<float_t>(convert_angle(1.0f, RAD, result_angle_unit));
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), ASIN_SPIRV_BIN, ASIN_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, factor);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the atan function;
// inverse function of tan(), i.e. returns the angle
// whose tangens equals a given value
NGrid NGrid::atan(AngularMeasure result_angle_unit) const {
	float_t factor = static_cast<float_t>(convert_angle(1.0f, RAD, result_angle_unit));
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), ATAN_SPIRV_BIN, ATAN_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, factor);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the hyperbolic cosine function
NGrid NGrid::cosh() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), COSH_SPIRV_BIN, COSH_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise applicatiohn of the hyperbolic sine function
NGrid NGrid::sinh() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), SINH_SPIRV_BIN, SINH_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the hyperbolic tangent function
NGrid NGrid::tanh() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), TANH_SPIRV_BIN, TANH_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the hyperbolic arc cosine function
NGrid NGrid::acosh() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), ACOSH_SPIRV_BIN, ACOSH_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the hyperbolic arc sine function
NGrid NGrid::asinh() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), ASINH_SPIRV_BIN, ASINH_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise application of the hyperbolic arc tangent function
NGrid NGrid::atanh() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), ATANH_SPIRV_BIN, ATANH_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Find, Replace                   |
// +=================================+

// searches the array buffer for the specified 'old_value' and
// replaces all occurrences by the 'new_value'
NGrid NGrid::replace(const float_t old_value, const float_t new_value) const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), REPLACE_SPIRV_BIN, REPLACE_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, old_value, new_value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// replaces all elements of 'this' with the corresponding element of the
// 'replacing_map' if the corresponding element of the condition map is !=0
NGrid NGrid::replace_if(const NGrid& condition_map, const NGrid& replacing_map) const {

	// check for equal dimensions
	if (this->dimensions != condition_map.get_dimensions() || this->dimensions != replacing_map.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::replace_if(): the dimensions of the source map, conditions map and replacing map must match; ",
			"source has shape ", this->get_shapestring(), ", condition map has shape ", condition_map.get_shapestring(),
			", replacing map has shape ", replacing_map.get_shapestring());
		return *this;
	}

	// check for equal sizes along dimensions
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != condition_map.get_shape()[i] || this->shape[i] != replacing_map.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::replace_if(): the dimensions of the source map, conditions map and replacing map must match; ",
				"source has shape ", this->get_shapestring(), ", condition map has shape ", condition_map.get_shapestring(),
				", replacing map has shape ", replacing_map.get_shapestring());
			return *this;
		}
	}

	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), REPLACE_MAP_IF_OTHER_SPIRV_BIN, REPLACE_MAP_IF_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*condition_map.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*replacing_map.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// replaces all elements of 'this' with the corresponding element of the
// 'replacing_map' if the corresponding element of the condition map is !=0
NGrid NGrid::replace_if(const NGrid& condition_map, const float_t replacing_value) const {

	// check for equal dimensions
	if (this->dimensions != condition_map.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::replace_if(): the dimensions of the source map and the conditions map must match; ",
			"source has shape ", this->get_shapestring(), ", condition map has shape ", condition_map.get_shapestring());
		return *this;
	}

	// check for equal sizes along dimensions
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != condition_map.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::replace_if(): the dimensions of the source map and the conditions map must match; ",
				"source has shape ", this->get_shapestring(), ", condition map has shape ", condition_map.get_shapestring());
			return *this;
		}
	}

	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), REPLACE_VALUE_IF_OTHER_SPIRV_BIN, REPLACE_VALUE_IF_OTHER_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*condition_map.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, replacing_value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// returns the number of occurrences of the specified value;
uint32_t NGrid::find(const float_t& value) const {
	static ShaderModule shader(manager->get_device(), FIND_SPIRV_BIN, FIND_SPIRV_BYTES);

	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return static_cast<uint32_t>(local_results.read_element(0));
}

// returns a NGrid array of equal dimensions as the source,
// with -1 for all corresponding negative values and +1 for all corresponding positive values
// (0 for all zeros)
NGrid NGrid::sign() const {
	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), SIGN_SPIRV_BIN, SIGN_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Scaling                         |
// +=================================+

// scale to specified range
NGrid NGrid::scale_minmax(float_t range_from, float_t range_to) const {
	static ShaderModule shader(manager->get_device(), SCALE_MINMAX_SPIRV_BIN, SCALE_MINMAX_SPIRV_BYTES);

	NGrid result(this->shape);
	Buffer<float> local_min_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));
	Buffer<float> local_max_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d)));

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_min_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_max_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, range_from, range_to);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// mean normalization scaling, i.e.
// (x - mean) / (max - min)
NGrid NGrid::scale_mean() const {
	static ShaderModule shader(manager->get_device(), SCALE_MEAN_SPIRV_BIN, SCALE_MEAN_SPIRV_BYTES);

	NGrid result(this->shape);
	uint32_t workgroups = static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d));
	Buffer<float> local_mean_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, workgroups);
	Buffer<float> local_min_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, workgroups);
	Buffer<float> local_max_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, workgroups);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_mean_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_min_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_max_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// 'standardized' scaling:
// scaling to zero mean and unit-variance, i.e.
// (x - mean) / sigma
NGrid NGrid::scale_std() const {
	static ShaderModule shader(manager->get_device(), SCALE_STD_SPIRV_BIN, SCALE_STD_SPIRV_BYTES);

	NGrid result(this->shape);
	uint32_t workgroups = static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d));
	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, workgroups);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Activation Functions            |
// +=================================+

NGrid NGrid::activation(ActFunc activation_function) const {
	switch (activation_function) {
	case ActFunc::RELU:
		return this->relu(0.0f);
		break;
	case ActFunc::LRELU:
		return this->relu(0.01f);
		break;
	case ActFunc::ELU:
		return this->elu(0.0f);
		break;
	case ActFunc::LELU:
		return this->elu(0.01f);
		break;
	case ActFunc::SIGMOID:
		return this->sigmoid();
		break;
	case ActFunc::TANH:
		return this->tanh();
		break;
	case ActFunc::IDENT:
		return this->ident();
		break;
	default:
		return *this;
		break;
	}
}

NGrid NGrid::derivative(ActFunc activation_function) const {
	switch (activation_function) {
	case ActFunc::RELU:
		return this->relu_drv(0.0f);
		break;
	case ActFunc::LRELU:
		return this->relu_drv(0.01f);
		break;
	case ActFunc::ELU:
		return elu_drv(0.0f);
		break;
	case ActFunc::LELU:
		return elu_drv(0.01f);
		break;
	case ActFunc::SIGMOID:
		return sigmoid_drv();
		break;
	case ActFunc::TANH:
		return tanh_drv();
		break;
	case ActFunc::IDENT:
		return ident_drv();
		break;
	default:
		return *this;
		break;
	}
}

// identity activation function
NGrid NGrid::ident() const {
	NGrid result(this->shape);
	result = *this; // copy constructor invocation
	return result;
}

// identity activation function derivative
NGrid NGrid::ident_drv() const {
	NGrid result(this->shape);
	result.fill(1.0f);
	return result;
}

// sigmoid activation function
// 1/(1+exp(-x))
NGrid NGrid::sigmoid() const {
	static ShaderModule shader(manager->get_device(), SIGMOID_SPIRV_BIN, SIGMOID_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// sigmoid activation derivative
// exp(x)/pow(exp(x)+1,2)
NGrid NGrid::sigmoid_drv() const {
	static ShaderModule shader(manager->get_device(), SIGMOID_DRV_SPIRV_BIN, SIGMOID_DRV_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// ELU activation function;
// x>0 ? x : alpha*(exp(x)-1)
NGrid NGrid::elu(float_t alpha) const {
	static ShaderModule shader(manager->get_device(), ELU_SPIRV_BIN, ELU_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, alpha);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// ELU activation derivative;
// chose alpha=0 for true ELU function;
// small alpha value like e.g. 0.01 for 'leaky' ELU
// x>0 ? 1 : alpha*exp(x);
NGrid NGrid::elu_drv(float_t alpha) const {
	static ShaderModule shader(manager->get_device(), ELU_DRV_SPIRV_BIN, ELU_DRV_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, alpha);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}


// ReLU activation function;
// chose alpha=0 for true ReLU function;
// small alpha value like e.g. 0.01 for 'leaky' ReLU
NGrid NGrid::relu(float_t alpha) const {
	static ShaderModule shader(manager->get_device(), RELU_SPIRV_BIN, RELU_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, alpha);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// ReLU activation derivative;
// chose alpha=0 for true ReLU function;
// small alpha value like e.g. 0.01 for 'leaky' ReLU
NGrid NGrid::relu_drv(float_t alpha) const {
	static ShaderModule shader(manager->get_device(), RELU_DRV_SPIRV_BIN, RELU_DRV_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, alpha);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// tanh activation derivative
NGrid NGrid::tanh_drv() const {
	static ShaderModule shader(manager->get_device(), TANH_DRV_SPIRV_BIN, TANH_DRV_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Outlier Treatment               |
// +=================================+

// truncate outliers by z-score mean deviation
NGrid NGrid::outliers_truncate(float_t z_score) const {
	static ShaderModule shader(manager->get_device(), OUTLIERS_TRUNCATE_SPIRV_BIN, OUTLIERS_TRUNCATE_SPIRV_BYTES);

	NGrid result(this->shape);
	uint32_t workgroups = static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d));
	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, workgroups);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, z_score);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// set outliers (by z-score) to mean
NGrid NGrid::outliers_mean_imputation(float_t z_score) const {
	static ShaderModule shader(manager->get_device(), OUTLIERS_MEAN_IMPUTATION_SPIRV_BIN, OUTLIERS_MEAN_IMPUTATION_SPIRV_BYTES);

	NGrid result(this->shape);
	uint32_t workgroups = static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d));
	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, workgroups);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, z_score);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// set outliers (by z-score) to value
NGrid NGrid::outliers_value_imputation(float_t value, float_t z_score) const {
	static ShaderModule shader(manager->get_device(), OUTLIERS_VALUE_IMPUTATION_SPIRV_BIN, OUTLIERS_VALUE_IMPUTATION_SPIRV_BYTES);

	NGrid result(this->shape);
	uint32_t workgroups = static_cast<uint32_t>(std::ceil(static_cast<float_t>(this->elements) / workgroup_size_1d));
	Buffer<float> local_results(manager->get_device(), BufferUsage::STORAGE_BUFFER, workgroups);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(local_results, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, z_score, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// recover -inf, +inf or nan values
// (replace with -FLOAT_MAX, +FLOAT_MAX or 0)
NGrid NGrid::recover() const {
	static ShaderModule shader(manager->get_device(), RECOVER_SPIRV_BIN, RECOVER_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Elementwise Comparison          |
// +=================================+

NGrid NGrid::operator>(const float_t value) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_GREATER_VALUE_SPIRV_BIN, OPERATOR_GREATER_VALUE_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}


NGrid NGrid::operator>=(const float_t value) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_GREATER_EQUAL_VALUE_SPIRV_BIN, OPERATOR_GREATER_EQUAL_VALUE_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator==(const float_t value) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_EQUAL_VALUE_SPIRV_BIN, OPERATOR_EQUAL_VALUE_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator!=(const float_t value) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_NOT_EQUAL_VALUE_SPIRV_BIN, OPERATOR_NOT_EQUAL_VALUE_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator<(const float_t value) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_SMALLER_VALUE_SPIRV_BIN, OPERATOR_SMALLER_VALUE_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator<=(const float_t value) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_SMALLER_EQUAL_VALUE_SPIRV_BIN, OPERATOR_SMALLER_EQUAL_VALUE_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements, value);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// elementwise comparison with second NGrid
NGrid NGrid::operator>(const NGrid& other) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_GREATER_OTHER_SPIRV_BIN, OPERATOR_GREATER_OTHER_SPIRV_BYTES);

	NGrid result(this->shape);

	if (this->dimensions != other.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::operator>(const NGrid& other) const: dimensions of 'this' and 'other' must match)");
		result.fill_zero();
		return result;
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != other.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::operator>(const NGrid& other) const: 'this'(", this->get_shapestring(),
				") and 'other'(", other.get_shapestring(), ") have different shape");
			result.fill_zero();
			return result;
		}
	}

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator>=(const NGrid& other) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_GREATER_EQUAL_OTHER_SPIRV_BIN, OPERATOR_GREATER_EQUAL_OTHER_SPIRV_BYTES);

	NGrid result(this->shape);

	if (this->dimensions != other.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::operator>=(const NGrid& other) const: dimensions of 'this' and 'other' must match)");
		result.fill_zero();
		return result;
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != other.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::operator>=(const NGrid& other) const: 'this'(", this->get_shapestring(),
				") and 'other'(", other.get_shapestring(), ") have different shape");
			result.fill_zero();
			return result;
		}
	}

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator==(const NGrid& other) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_EQUAL_OTHER_SPIRV_BIN, OPERATOR_EQUAL_OTHER_SPIRV_BYTES);

	NGrid result(this->shape);

	if (this->dimensions != other.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::operator==(const NGrid& other) const: dimensions of 'this' and 'other' must match)");
		result.fill_zero();
		return result;
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != other.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::operator==(const NGrid& other) const: 'this'(", this->get_shapestring(),
				") and 'other'(", other.get_shapestring(), ") have different shape");
			result.fill_zero();
			return result;
		}
	}

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator!=(const NGrid& other) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_NOT_EQUAL_OTHER_SPIRV_BIN, OPERATOR_NOT_EQUAL_OTHER_SPIRV_BYTES);

	NGrid result(this->shape);

	if (this->dimensions != other.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::operator!=(const NGrid& other) const: dimensions of 'this' and 'other' must match)");
		result.fill_zero();
		return result;
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != other.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::operator!=(const NGrid& other) const: 'this'(", this->get_shapestring(),
				") and 'other'(", other.get_shapestring(), ") have different shape");
			result.fill_zero();
			return result;
		}
	}

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator<(const NGrid& other) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_SMALLER_OTHER_SPIRV_BIN, OPERATOR_SMALLER_OTHER_SPIRV_BYTES);

	NGrid result(this->shape);

	if (this->dimensions != other.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::operator<(const NGrid& other) const: dimensions of 'this' and 'other' must match)");
		result.fill_zero();
		return result;
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != other.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::operator<(const NGrid& other) const: 'this'(", this->get_shapestring(),
				") and 'other'(", other.get_shapestring(), ") have different shape");
			result.fill_zero();
			return result;
		}
	}

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator<=(const NGrid& other) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_SMALLER_EQUAL_OTHER_SPIRV_BIN, OPERATOR_SMALLER_EQUAL_OTHER_SPIRV_BYTES);

	NGrid result(this->shape);

	if (this->dimensions != other.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::operator<=(const NGrid& other) const: dimensions of 'this' and 'other' must match)");
		result.fill_zero();
		return result;
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != other.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::operator<=(const NGrid& other) const: 'this'(", this->get_shapestring(),
				") and 'other'(", other.get_shapestring(), ") have different shape");
			result.fill_zero();
			return result;
		}
	}

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | Elementwise Logial Operations   |
// +=================================+

// elementwise logical 'and'
NGrid NGrid::operator&&(const bool value) const {
	if (value == false) {
		NGrid result(this->shape);
		result.fill_zero();
		return result;
	}
	else {
		return this->operator!=(0.0f);
	}
}

// elementwise logical 'or'
NGrid NGrid::operator||(const bool value) const {
	if (value == true) {
		NGrid result(this->shape);
		result.fill(1);
		return result;
	}
	else {
		return this->operator!=(0.0f);
	}
}

NGrid NGrid::operator!() const {
	static ShaderModule shader(manager->get_device(), OPERATOR_NOT_SPIRV_BIN, OPERATOR_NOT_SPIRV_BYTES);

	NGrid result(this->shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator&&(const NGrid& other) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_AND_OTHER_SPIRV_BIN, OPERATOR_AND_OTHER_SPIRV_BYTES);

	NGrid result(this->shape);

	if (this->dimensions != other.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::operator&&(const NGrid& other) const: dimensions of 'this' and 'other' must match)");
		result.fill_zero();
		return result;
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != other.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::operator&&(const NGrid& other) const: 'this'(", this->get_shapestring(),
				") and 'other'(", other.get_shapestring(), ") have different shape");
			result.fill_zero();
			return result;
		}
	}

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::operator||(const NGrid& other) const {
	static ShaderModule shader(manager->get_device(), OPERATOR_OR_OTHER_SPIRV_BIN, OPERATOR_OR_OTHER_SPIRV_BYTES);

	NGrid result(this->shape);

	if (this->dimensions != other.get_dimensions()) {
		Log::warning("invalid usage of method NGrid::operator||(const NGrid& other) const: dimensions of 'this' and 'other' must match)");
		result.fill_zero();
		return result;
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != other.get_shape()[i]) {
			Log::warning("invalid usage of method NGrid::operator||(const NGrid& other) const: 'this'(", this->get_shapestring(),
				") and 'other'(", other.get_shapestring(), ") have different shape");
			result.fill_zero();
			return result;
		}
	}

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	PushConstants constants(this->elements);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+   
// | dynamic handling                |
// +=================================+

// conversion to 1d array
NGrid NGrid::flatten() const {
	NGrid result(this->elements);
	result.get_buffer()->write(*this->data_buffer);
	return result;
}

// reshapes (resizes) the underlying array buffer to the specified dimensions;
// any new elements get initialized to the given value (default: 0)
NGrid NGrid::reshape(const std::vector<uint32_t>& new_shape, float_t default_init_value) const {
	NGrid result(new_shape);

	// check for empty source grid
	// (this is required because empty grids have no valid data_buffer or shape_buffer)
	if (this->elements == 0) {
		result.fill(default_init_value);
	}
	else {
		// load shader
		static ShaderModule shader(manager->get_device(), RESIZE_SPIRV_BIN, RESIZE_SPIRV_BYTES);

		// bind buffers to a descriptor set
		DescriptorSet set(manager->get_device());
		set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.finalize_layout();
		descriptor_pool->allocate_set(set);

		// define push constants
		PushConstants constants(
			this->dimensions,
			result.get_dimensions(),
			this->elements,
			result.get_elements(),
			default_init_value
		);

		// execute compute pipeline
		ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
		command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
		descriptor_pool->release_set(set);
	}
	return result;
}

NGrid NGrid::reshape(std::initializer_list<uint32_t> new_shape, float_t default_init_value) const {
	std::vector<uint32_t> new_shape_vec(new_shape);
	return this->reshape(new_shape_vec, default_init_value);
}

// stitch two NGrid arrays together along the specified axis
NGrid NGrid::concatenate(const NGrid& other, const uint32_t axis) const {
	// check valid axis argument
	if (axis > this->dimensions + 1) {
		Log::warning("invalid call of NGrid::concatenate() along axis ", axis, "; the array so far only has ",
			this->dimensions, " dimensions (shape ", this->get_shapestring(), "), returning 'this' as unmodified");
		return *this;
	}
	// check valid sizes
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (i != axis) {
			if (this->shape[i] != other.get_shape()[i]) {
				Log::warning("invalid call of NGrid::concatenate(): 'this' has size ", this->shape[i],
					" in dimension ", i, " but 'other' has size ", other.get_shape()[i], " in dimension ", i,
					", therefore these two arrays can't be stiched together properly; returning 'this' as unmodified");
				return *this;
			}
		}
	}

	static ShaderModule shader(manager->get_device(), CONCATENATE_SPIRV_BIN, CONCATENATE_SPIRV_BYTES);

	std::vector<uint32_t> result_shape = this->shape;
	if (axis == this->dimensions + 1) {
		result_shape.push_back(1);
	}
	result_shape[axis] += other.get_dimensions() <= axis ? 1 : other.get_shape()[axis];

	NGrid result(result_shape);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*other.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);

	PushConstants constants(
		this->dimensions,
		other.get_dimensions(),
		result.get_dimensions(),
		this->elements,
		result.get_elements(),
		axis
	);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}

// padding around vector/matrix/array using the passed value 
NGrid NGrid::padding(const uint32_t amount, const float_t init_value) const {

	std::vector<uint32_t> result_shape = this->shape;
	for (uint32_t i = 0; i < this->dimensions; i++) {
		result_shape[i] += 2 * amount;
	}
	NGrid result(result_shape);

	static ShaderModule shader(manager->get_device(), PADDING_SPIRV_BIN, PADDING_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	PushConstants constants(
		this->dimensions,
		this->elements,
		result.get_elements(),
		amount,
		init_value
	);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);

	return result;
}
NGrid NGrid::pool_max(const std::vector<uint32_t>& window_shape, const std::vector<uint32_t>& stride_shape) const {
	if (window_shape.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::pool_max: window shape size must match the number of dimensions of the grid");
		return *this; // return unmodified grid
	}
	if (stride_shape.size() != 0 && stride_shape.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::pool_max: step shape size must match the number of dimensions of the grid");
		return *this; // return unmodified grid
	}

	// copy window shape to a storage buffer
	Buffer<uint32_t> window_shape_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, window_shape.size());
	window_shape_buffer.write(window_shape);

	// calculate window elements
	uint32_t window_N = 1;
	for (uint32_t i = 0; i < window_shape.size(); i++) {
		window_N *= window_shape[i];
	}

	// copy stride shape to a storage buffer
	// (if stride shape is empty, use window shape as default)
	Buffer<uint32_t> stride_shape_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions);
	stride_shape_buffer.write(stride_shape.size() == 0 ? window_shape : stride_shape);


	// calculate result shape
	std::vector<uint32_t> result_shape;
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (window_shape[i] == 0) {
			Log::warning("invalid usage of NGrid::pool_max: window shape must not contain zero values");
			return *this; // return unmodified grid
		}
		if (stride_shape.size() == 0) {
			result_shape.push_back(std::max(1u, (this->shape[i] + window_shape[i] - 1) / window_shape[i]));
		}
		else {
			result_shape.push_back(std::max(1u, (this->shape[i] + stride_shape[i] - 1) / stride_shape[i]));
		}
	}
	NGrid result(result_shape);

	static ShaderModule shader(manager->get_device(), POOL_MAX_SPIRV_BIN, POOL_MAX_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(window_shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(stride_shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	PushConstants constants(
		this->dimensions,
		this->elements,
		result.get_elements(),
		window_N
	);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
	return result;
}

NGrid NGrid::pool_max(const std::initializer_list<uint32_t>& window_shape, const std::initializer_list<uint32_t>& stride_shape) const {
	std::vector<uint32_t> window_shape_vec(window_shape);
	std::vector<uint32_t> stride_shape_vec(stride_shape);
	return this->pool_max(window_shape_vec, stride_shape_vec);
}

NGrid NGrid::pool_maxabs(const std::vector<uint32_t>& window_shape, const std::vector<uint32_t>& stride_shape) const {
	if (window_shape.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::pool_max: window shape size must match the number of dimensions of the grid");
		return *this; // return unmodified grid
	}
	if (stride_shape.size() != 0 && stride_shape.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::pool_max: step shape size must match the number of dimensions of the grid");
		return *this; // return unmodified grid
	}

	// copy window shape to a storage buffer
	Buffer<uint32_t> window_shape_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, window_shape.size());
	window_shape_buffer.write(window_shape);

	// calculate window elements
	uint32_t window_N = 1;
	for (uint32_t i = 0; i < window_shape.size(); i++) {
		window_N *= window_shape[i];
	}

	// copy stride shape to a storage buffer
	// (if stride shape is empty, use window shape as default)
	Buffer<uint32_t> stride_shape_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions);
	stride_shape_buffer.write(stride_shape.size() == 0 ? window_shape : stride_shape);

	// calculate result shape
	std::vector<uint32_t> result_shape;
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (window_shape[i] == 0) {
			Log::warning("invalid usage of NGrid::pool_max: window shape must not contain zero values");
			return *this; // return unmodified grid
		}
		if (stride_shape.size() == 0) {
			result_shape.push_back(std::max(1u, (this->shape[i] + window_shape[i] - 1) / window_shape[i]));
		}
		else {
			result_shape.push_back(std::max(1u, (this->shape[i] + stride_shape[i] - 1) / stride_shape[i]));
		}
	}
	NGrid result(result_shape);

	static ShaderModule shader(manager->get_device(), POOL_MAXABS_SPIRV_BIN, POOL_MAXABS_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(window_shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(stride_shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	PushConstants constants(
		this->dimensions,
		this->elements,
		result.get_elements(),
		window_N
	);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
	return result;
}

NGrid NGrid::pool_maxabs(const std::initializer_list<uint32_t>& window_shape, const std::initializer_list<uint32_t>& stride_shape) const {
	std::vector<uint32_t> window_shape_vec(window_shape);
	std::vector<uint32_t> stride_shape_vec(stride_shape);
	return this->pool_maxabs(window_shape_vec, stride_shape_vec);
}

NGrid NGrid::pool_min(const std::vector<uint32_t>& window_shape, const std::vector<uint32_t>& stride_shape) const {
	if (window_shape.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::pool_max: window shape size must match the number of dimensions of the grid");
		return *this; // return unmodified grid
	}
	if (stride_shape.size() != 0 && stride_shape.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::pool_max: step shape size must match the number of dimensions of the grid");
		return *this; // return unmodified grid
	}

	// copy window shape to a storage buffer
	Buffer<uint32_t> window_shape_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, window_shape.size());
	window_shape_buffer.write(window_shape);

	// calculate window elements
	uint32_t window_N = 1;
	for (uint32_t i = 0; i < window_shape.size(); i++) {
		window_N *= window_shape[i];
	}

	// copy stride shape to a storage buffer
	// (if stride shape is empty, use window shape as default)
	Buffer<uint32_t> stride_shape_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions);
	stride_shape_buffer.write(stride_shape.size() == 0 ? window_shape : stride_shape);

	// calculate result shape
	std::vector<uint32_t> result_shape;
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (window_shape[i] == 0) {
			Log::warning("invalid usage of NGrid::pool_max: window shape must not contain zero values");
			return *this; // return unmodified grid
		}
		if (stride_shape.size() == 0) {
			result_shape.push_back(std::max(1u, (this->shape[i] + window_shape[i] - 1) / window_shape[i]));
		}
		else {
			result_shape.push_back(std::max(1u, (this->shape[i] + stride_shape[i] - 1) / stride_shape[i]));
		}
	}
	NGrid result(result_shape);

	static ShaderModule shader(manager->get_device(), POOL_MIN_SPIRV_BIN, POOL_MIN_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(window_shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(stride_shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	PushConstants constants(
		this->dimensions,
		this->elements,
		result.get_elements(),
		window_N
	);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
	return result;
}

NGrid NGrid::pool_min(const std::initializer_list<uint32_t>& window_shape, const std::initializer_list<uint32_t>& stride_shape) const {
	std::vector<uint32_t> window_shape_vec(window_shape);
	std::vector<uint32_t> stride_shape_vec(stride_shape);
	return this->pool_min(window_shape_vec, stride_shape_vec);
}

NGrid NGrid::pool_mean(const std::vector<uint32_t>& window_shape, const std::vector<uint32_t>& stride_shape) const {
	if (window_shape.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::pool_max: window shape size must match the number of dimensions of the grid");
		return *this; // return unmodified grid
	}
	if (stride_shape.size() != 0 && stride_shape.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::pool_max: step shape size must match the number of dimensions of the grid");
		return *this; // return unmodified grid
	}

	// copy window shape to a storage buffer
	Buffer<uint32_t> window_shape_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, window_shape.size());
	window_shape_buffer.write(window_shape);

	// calculate window elements
	uint32_t window_N = 1;
	for (uint32_t i = 0; i < window_shape.size(); i++) {
		window_N *= window_shape[i];
	}

	// copy stride shape to a storage buffer
	// (if stride shape is empty, use window shape as default)
	Buffer<uint32_t> stride_shape_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions);
	stride_shape_buffer.write(stride_shape.size() == 0 ? window_shape : stride_shape);

	// calculate result shape
	std::vector<uint32_t> result_shape;
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (window_shape[i] == 0) {
			Log::warning("invalid usage of NGrid::pool_max: window shape must not contain zero values");
			return *this; // return unmodified grid
		}
		if (stride_shape.size() == 0) {
			result_shape.push_back(std::max(1u, (this->shape[i] + window_shape[i] - 1) / window_shape[i]));
		}
		else {
			result_shape.push_back(std::max(1u, (this->shape[i] + stride_shape[i] - 1) / stride_shape[i]));
		}
	}
	NGrid result(result_shape);

	// load shader
	static ShaderModule shader(manager->get_device(), POOL_MEAN_SPIRV_BIN, POOL_MEAN_SPIRV_BYTES);

	// define descriptor set
	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(window_shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(stride_shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	// define push constants
	PushConstants constants(
		this->dimensions,
		this->elements,
		result.get_elements(),
		window_N
	);

	// execute compute pipeline
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
	return result;
}

NGrid NGrid::pool_mean(const std::initializer_list<uint32_t>& window_shape, const std::initializer_list<uint32_t>& stride_shape) const {
	std::vector<uint32_t> window_shape_vec(window_shape);
	std::vector<uint32_t> stride_shape_vec(stride_shape);
	return this->pool_mean(window_shape_vec, stride_shape_vec);
}

NGrid NGrid::convolution(const NGrid& kernel, uint32_t padding_amount, float_t padding_value) const {
	// check if kernel has valid dimensions
	if (kernel.get_dimensions() != this->dimensions) {
		Log::warning("invalid usage of NGrid::convolution: dimensions of 'kernel' (", kernel.get_dimensions(),
			") must match the dimensions of 'this' (", this->dimensions, ")");
		return *this; // return unmodified grid
	}

	// calculate result shape
	std::vector<uint32_t> result_shape = this->shape;
	for (uint32_t i = 0; i < this->dimensions; i++) {
		result_shape[i] = result_shape[i] - kernel.get_shape()[i] + 1 + (2 * padding_amount);
	}
	NGrid result(result_shape);

	// load shader
	static ShaderModule shader(manager->get_device(), CONVOLUTION_SPIRV_BIN, CONVOLUTION_SPIRV_BYTES);

	// define descriptor set
	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*kernel.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*kernel.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	// define push constants
	PushConstants constants(
		this->dimensions,
		this->elements,
		result.get_elements(),
		kernel.get_elements(),
		padding_amount,
		padding_value
	);

	// execute compute pipeline
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
	command_buffer->compute(pipeline, result.get_elements(), 1, 1, true, fence_timeout_nanosec);
	descriptor_pool->release_set(set);
	return result;
}

NGrid NGrid::transpose(const std::vector<uint32_t> target_axis_order) const {

	// check if target axis order is valid
	if (target_axis_order.size() < 2 || (target_axis_order.size() >= 2 && target_axis_order.size() != this->dimensions)) {
		Log::warning("invalid usage of NGrid::transpose: target axis order size (", target_axis_order.size(),
			") must be >=2 and it must match the number of dimensions of 'this' (", this->dimensions, ")");
		return *this; // return unmodified grid
	}
	// check if target axis order contains all axes exactly once
	std::vector<uint32_t> result_shape(std::max(2u, this->dimensions));
	for (uint32_t i = 0; i < this->dimensions; i++) {
		for (uint32_t j = 0; j < this->dimensions; j++) {
			if (i != j && target_axis_order[i] == target_axis_order[j]) {
				Log::warning("invalid usage of NGrid::transpose: target axis order must contain all axes exactly once");
				return *this; // return unmodified grid
			}
		}
		result_shape[i] = this->shape[target_axis_order[i]];
	}

	// create result + buffer to store the target axis order
	NGrid result(result_shape);
	Buffer<uint32_t> target_axis_order_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, target_axis_order.size());
	target_axis_order_buffer.write(target_axis_order);

	// load shader
	static ShaderModule shader(manager->get_device(), TRANSPOSE_SPIRV_BIN, TRANSPOSE_SPIRV_BYTES);

	// define push constants
	PushConstants constants(
		std::max(2u, this->dimensions),
		this->elements
	);

	// if 'this' is 1d, it has to be reshaped to a [n, 1] 2d matrix before transposing
	// (a copy of 'this' is needed, because this is a non-destructive (const) operation)
	if (this->dimensions == 1) {
		NGrid data_cpy = *this;
		data_cpy.reshape({ this->shape[0], 1 }); // reshape to [n, 1]

		// define descriptor set
		DescriptorSet set(manager->get_device());
		set.bind_buffer(*data_cpy.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(target_axis_order_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.finalize_layout();
		descriptor_pool->allocate_set(set);

		// execute compute pipeline
		ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
		command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
		descriptor_pool->release_set(set);
	}
	// if 'this' is 2d or higher, it can be transposed directly
	else {
		// define descriptor set
		DescriptorSet set(manager->get_device());
		set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(target_axis_order_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.bind_buffer(*result.get_shape_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
		set.finalize_layout();
		descriptor_pool->allocate_set(set);

		// execute compute pipeline
		ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);
		command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
		descriptor_pool->release_set(set);
	}
	return result;
}

void  NGrid::lu_decomp(NGrid& L, NGrid& U, NGrid& P) const {
	// check if the grid is a 2d matrix
	if (this->dimensions != 2) {
		Log::warning("invalid usage of NGrid::lu_decomp: only 2d matrices can be decomposed, returning unmodified grids");
		return;
	}

	// initialize matrices
	// L is a lower triangular matrix, U is an upper triangular matrix, P is a permutation matrix
	// please note that L and P are square matrices, while U (as a 'row echelon matrix') has the same shape as the source matrix
	L = L.reshape({ this->shape[0], this->shape[0] });	L.fill_identity();
	U = *this; // U is initialized with the source matrix
	P = P.reshape({ this->shape[0], this->shape[0] });	P.fill_identity();

	// add a buffer to store the row to be swapped for current row 'k'
	Buffer<uint32_t> swap_row(manager->get_device(), BufferUsage::STORAGE_BUFFER, 1);

	// define descriptor set
	DescriptorSet set(manager->get_device());
	set.bind_buffer(*L.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*U.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*P.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(swap_row, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	// define push constants
	uint32_t k = 0;
	PushConstants constants(
		this->shape[0],		// source matrix rows
		this->shape[1],		// source matrix columns
		k					// current row index
	);

	// main iterative loop for LU decomposition;
	for (k = 0; k < this->shape[0]; k++) {

		// update k in push constants (at offset 8 bytes)
		constants.add_values(k, 8);

		// check if row swap is needed
		// (1d dispatch with one thread for each row)
		static ShaderModule check_swap_shader(manager->get_device(), LU_DECOMP_CHECK_ROWSWAP_SPIRV_BIN, LU_DECOMP_CHECK_ROWSWAP_SPIRV_BYTES);
		ComputePipeline check_swap_pipeline(manager->get_device(), check_swap_shader, constants, set, workgroup_size_1d, 1, 1);
		command_buffer->compute(check_swap_pipeline, this->shape[0], 1, 1, false, 0, true);

		// perform row swap (=if needed)
		// (horizontal 1d dispatch with one thread for each column)
		static ShaderModule perform_swap_shader(manager->get_device(), LU_DECOMP_PERFORM_ROWSWAP_SPIRV_BIN, LU_DECOMP_PERFORM_ROWSWAP_SPIRV_BYTES);
		ComputePipeline perform_swap_pipeline(manager->get_device(), perform_swap_shader, constants, set, workgroup_size_1d, 1, 1);
		command_buffer->compute(perform_swap_pipeline, this->shape[1], 1, 1, false, 0, true);

		// update L matrix in column k
		// (1d dispatch with one thread for each row)
		static ShaderModule l_update_shader(manager->get_device(), LU_DECOMP_L_UPDATE_SPIRV_BIN, LU_DECOMP_L_UPDATE_SPIRV_BYTES);
		ComputePipeline l_update_pipeline(manager->get_device(), l_update_shader, constants, set, workgroup_size_1d, 1, 1);
		command_buffer->compute(l_update_pipeline, this->shape[0], 1, 1, false, 0, true);

		// update U matrix in rows [k+1] to [rows-1]
		static ShaderModule u_update_shader(manager->get_device(), LU_DECOMP_U_UPDATE_SPIRV_BIN, LU_DECOMP_U_UPDATE_SPIRV_BYTES);
		ComputePipeline u_update_pipeline(manager->get_device(), u_update_shader, constants, set, workgroup_size_1d, 1, 1);
		command_buffer->compute(u_update_pipeline, U.get_elements(), 1, 1, true, fence_timeout_nanosec, true);
	}
	descriptor_pool->release_set(set);
}

// get the inverse of a lower triangular matrix L (using forward substitution)
NGrid NGrid::l_inverse() const {
	if (this->dimensions != 2 || this->shape[0] != this->shape[1]) {
		Log::warning("invalid usage of method NGrid::l_inverse(): the underlying NGrid must be a 2d square matrix -> returning 'this' as unmodified");
		return *this;
	}

	// load shader module
	static ShaderModule shader(manager->get_device(), L_INVERSE_SPIRV_BIN, L_INVERSE_SPIRV_BYTES);

	// create an identity matrix of this->shape
	NGrid I(this->shape);
	I.fill_identity();

	// define descriptor set
	DescriptorSet set(manager->get_device());
	set.bind_buffer(*this->data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*I.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	// define push constants
	PushConstants constants(
		this->shape[0]
	);

	// execute compute pipeline
	// (1d dispatch with one thread for each column)
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d, 1, 1);
	command_buffer->compute(pipeline, this->shape[1], 1, 1, true, fence_timeout_nanosec, true);

	descriptor_pool->release_set(set);
	return I;
}

// get the inverse of an upper triangular matrix U (using backward substitution)
NGrid NGrid::u_inverse() const {

	if (this->dimensions != 2 || this->shape[0] != this->shape[1]) {
		Log::warning("invalid usage of method NGrid::l_inverse(): the underlying NGrid must be a 2d square matrix -> returning 'this' as unmodified");
		return *this;
	}

	// load shader module
	static ShaderModule shader(manager->get_device(), U_INVERSE_SPIRV_BIN, U_INVERSE_SPIRV_BYTES);

	// create an identity matrix of this->shape
	NGrid I(this->shape);
	I.fill_identity();

	// define descriptor set
	DescriptorSet set(manager->get_device());
	set.bind_buffer(*this->data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*I.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	// define push constants
	PushConstants constants(
		this->shape[0]
	);

	// execute compute pipeline
	// (1d dispatch with one thread for each column)
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d, 1, 1);
	command_buffer->compute(pipeline, this->shape[1], 1, 1, true, fence_timeout_nanosec, true);

	descriptor_pool->release_set(set);
	return I;
}

// 2d matrix inversion
// this algorithm uses LU decomposition and obtains A_inv = L_inv * U_inv * P;
// in case of a non-square matrix, the Moore-Penrose pseudo-inverse is calculated;
NGrid NGrid::inverse() const {

	// check if the grid is a 2d matrix
	if (this->dimensions != 2) {
		Log::warning("invalid usage of NGrid::inverse: only 2d matrices can be inverted, returning unmodified grid");
		return *this;
	}

	// case 1: square matrix
	if (this->shape[0] == this->shape[1]) {
		NGrid L, U, P, A_inv;
		this->lu_decomp(L, U, P);
		A_inv = U.u_inverse() * L.l_inverse() * P;
		return A_inv;
	}

	// case 2: 'tall' matrix (m x n, with m > n)
	// calculate the Moore-Penrose pseudo-inverse
	else if (this->shape[0] > this->shape[1]) {
		return (this->transpose() * *this).inverse() * this->transpose(); // A+ = (A^T * A)^-1 * A^T
	}

	// case 3: 'wide' matrix (m x n, with m < n)
	// calculate the Moore-Penrose pseudo-inverse
	else if (this->shape[0] < this->shape[1]) {
		return this->transpose() * (*this * this->transpose()).inverse(); // A+ = A^T * (A * A^T)^-1
	}
	return *this;
}

// reverse sorting (=mirror, =flip) of the grid along the specified axes
NGrid NGrid::mirror(const std::vector<bool>& mirror_axes) const {
	// check if the number of axes to mirror matches the number of dimensions
	if (mirror_axes.size() != 0 && mirror_axes.size() != this->dimensions) {
		Log::warning("invalid usage of NGrid::mirror: mirror axes size (", mirror_axes.size(),
			") must match the number of dimensions of 'this' (", this->dimensions, ")");
		return *this; // return unmodified grid
	}

	// copy the mirror axes to a storage buffer
	Buffer<uint32_t> mirror_axes_buffer(manager->get_device(), BufferUsage::STORAGE_BUFFER, this->dimensions);
	if (mirror_axes.size() == 0) {
		// if no axes are specified, mirror all axes
		for (uint32_t i = 0; i < this->dimensions; i++) {
			mirror_axes_buffer.write_element(i, 1); // 1 = true
		}
	}
	else {
		for (uint32_t i = 0; i < this->dimensions; i++) {
			mirror_axes_buffer.write_element(i, uint32_t(mirror_axes[i]));
		}
	}

	// create a buffer for the result grid
	NGrid result(this->shape);

	// load shader
	static ShaderModule shader(manager->get_device(), MIRROR_SPIRV_BIN, MIRROR_SPIRV_BYTES);

	// define push constants
	PushConstants constants(
		this->elements,
		this->dimensions
	);

	// define descriptor set
	DescriptorSet set(manager->get_device());
	set.bind_buffer(*this->data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*this->shape_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(mirror_axes_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	// execute compute pipeline
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d, 1, 1);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec, true);
	descriptor_pool->release_set(set);

	return result;
}

NGrid NGrid::mirror(const std::initializer_list<bool>& mirror_axes) const {
	std::vector<bool> mirror_axes_vec(mirror_axes);
	return this->mirror(mirror_axes_vec);
}

// rearrange the source array elements based on a target index map
// (holding the flat indices corresponding to the new locations of the elements, as they are mapped to the result NGrid)
NGrid NGrid::remap(const NGrid& target_index_map) const {

	// check if the target index map has the same shape as the source grid
	if (this->dimensions != target_index_map.get_dimensions()) {
		Log::warning("invalid usage of NGrid::remap: dimensions of 'this' (", this->dimensions,
			") must match the dimensions of 'target_index_map' (", target_index_map.get_dimensions(), ")");
		return *this; // return unmodified grid
	}
	for (uint32_t i = 0; i < this->dimensions; i++) {
		if (this->shape[i] != target_index_map.get_shape()[i]) {
			Log::warning("invalid usage of NGrid::remap: shape of 'this' (", this->get_shapestring(), ") must match the shape of 'target_index_map' (", target_index_map.get_shapestring(), ")");
			return *this; // return unmodified grid
		}
	}

	// create result NGrid with the same shape as the source grid
	NGrid result(this->shape);

	// load shader
	static ShaderModule shader(manager->get_device(), REMAP_SPIRV_BIN, REMAP_SPIRV_BYTES);

	// define descriptor set
	DescriptorSet set(manager->get_device());
	set.bind_buffer(*this->data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*target_index_map.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();
	descriptor_pool->allocate_set(set);

	// define push constants
	PushConstants constants(
		this->elements
	);

	// execute compute pipeline
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d, 1, 1);
	command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec, true);
	descriptor_pool->release_set(set);

	return result;
}

// +=================================+
// | 1d vector statistics            |
// +=================================+

// return struct for correlation results
struct NGrid::RegressionResult {
	friend class NGrid; // allow NGrid to access private members
public:

	// default constructor = delete
	RegressionResult() = delete;

	// constructor
	RegressionResult(uint32_t n, uint32_t k) {
		coefficients = new NGrid; // size k+1 (has to be initialized later, when k is known)
		y_predict = new NGrid(n, 1); // predicted y values (Y_hat)
	}

	// destructor
	~RegressionResult() {
		if (coefficients) {
			delete coefficients; // delete coefficients grid
			coefficients = nullptr;
		}
		if (y_predict) {
			delete y_predict; // delete predicted y values grid
			y_predict = nullptr;
		}
	}

	// print linear correlation results to the console
	void print() const {
		std::cout
			<< "=========================================================================="
			<< "\nCorrelation Results (this=x vs. other=y):"
			<< "\n   - number of observations (N) = " << num_observations
			<< "\n   - number of parameters (k+1) = " << num_params
			<< "\n   - number of predictors (k) = " << num_predictors
			<< "\n   - mean value of the dependent variable 'y' = " << y_mean
			<< "\n   - variance of the dependent variable 'y' = " << y_variance
			<< "\n   - standard deviation of y = " << y_stddev
			<< "\n   - coefficient of determination (r-squared) = " << r_squared
			<< "\n   - adjusted r-squared = " << adjusted_r_squared
			<< "\n   - total sum of squares (SST) = " << SST
			<< "\n   - explained sum of squares (SSE) = " << SSE
			<< "\n   - residual sum of squares (SSR) = " << SSR
			<< "\n   - mean squared error (MSE) = " << MSE
			<< "\n   - mean squared regression (MSR) = " << MSR << std::endl;
		if (is_simple_linear) {
			std::cout
				<< "\nadditional metrics for simple linear regression:"
				<< "\n   - mean value of the independent variable 'x' = " << x_mean
				<< "\n   - variance of the independent variable 'x' = " << x_variance
				<< "\n   - standard deviation of x = " << x_stddev
				<< "\n   - covariance between x & y = " << covariance
				<< "\n   - Pearson correlation coefficient R = " << Pearson_R
				<< "\n   - intercept (beta_0) = " << coefficients_vec[0]
				<< "\n   - slope (beta_1) = " << coefficients_vec[1] << std::endl;
		}
		else {
			std::cout
				<< "\n   - regression coefficients (beta_hat) = " << coefficients_to_string() << std::endl;
		}
		std::cout
			<< "\n==========================================================================" << std::endl;
	}

	// getter functions
	inline NGrid get_coefficients() const { return *coefficients; }

	inline NGrid get_y_predict() const { return *y_predict; }

	inline uint32_t get_num_observations() const { return num_observations; }

	inline uint32_t get_num_params() const { return num_params; }

	inline uint32_t get_num_predictors() const { return num_predictors; }

	inline float_t get_r_squared() const { return r_squared; }

	inline float_t get_adjusted_r_squared() const { return adjusted_r_squared; }

	inline float_t get_SST() const { return SST; }

	inline float_t get_SSE() const { return SSE; }

	inline float_t get_SSR() const { return SSR; }

	inline float_t get_MSE() const { return MSE; }

	inline float_t get_MSR() const { return MSR; }

	inline float_t get_y_variance() const { return y_variance; }

	inline float_t get_y_stddev() const { return y_stddev; }

	inline float_t get_y_mean() const { return y_mean; }

	inline float_t get_x_mean() const {
		if (!is_simple_linear) {
			Log::warning("invalid usage of NGrid::RegressionResult::get_x_mean(): this is not a simple linear regression result, returning NAN");
			return float_t(NAN);
		}
		return x_mean;
	}

	inline float_t get_x_variance() const {
		if (!is_simple_linear) {
			Log::warning("invalid usage of NGrid::RegressionResult::get_x_variance(): this is not a simple linear regression result, returning NAN");
			return float_t(NAN);
		}
		return x_variance;
	}

	inline float_t get_x_stddev() const {
		if (!is_simple_linear) {
			Log::warning("invalid usage of NGrid::RegressionResult::get_x_stddev(): this is not a simple linear regression result, returning NAN");
			return float_t(NAN);
		}
		return x_stddev;
	}

	inline float_t get_covariance() const {
		if (!is_simple_linear) {
			Log::warning("invalid usage of NGrid::RegressionResult::get_covariance(): this is not a simple linear regression result, returning NAN");
			return float_t(NAN);
		}
		return covariance;
	}

	inline float_t get_Pearson_R() const {
		if (!is_simple_linear) {
			Log::warning("invalid usage of NGrid::RegressionResult::get_Pearson_R(): this is not a simple linear regression result, returning NAN");
			return float_t(NAN);
		}
		return Pearson_R;
	}

private:
	NGrid* coefficients = nullptr;	// regression coefficients (beta_hat)
	std::vector<float_t> coefficients_vec; // vector to store coefficients (for convenience)
	NGrid* y_predict = nullptr;		// predicted y values (Y_hat)
	uint32_t num_observations = 0;	// number of observations (N)
	uint32_t num_params = 0;		// number of parameters (k+1, including intercept)
	uint32_t num_predictors = 0;	// number of independent variables (k)
	float_t x_mean = 0;
	float_t y_mean = 0;
	float_t x_variance = 0;
	float_t y_variance = 0;
	float_t x_stddev = 0;
	float_t y_stddev = 0;
	float_t covariance = 0;
	float_t Pearson_R = 0;
	float_t r_squared = 0;
	float_t adjusted_r_squared = 0; // adjusted r-squared
	float_t SST = 0;
	float_t SSE = 0;
	float_t SSR = 0;
	float_t MSE = 0;
	float_t MSR = 0;
	bool is_simple_linear = false;

	// helper function to convert the coefficients to a string
	std::string coefficients_to_string() const {
		if (coefficients == nullptr) {
			return "No coefficients available.";
		}
		// copy contents of coefficients NGrid to a std::vector
		std::string result = "[";
		for (uint32_t i = 0; i < coefficients_vec.size(); i++) {
			result += std::to_string(coefficients_vec[i]);
			if (i < coefficients_vec.size() - 1) {
				result += ", ";
			}
		}
		result += "]";
		return result;
	}
};

NGrid::RegressionResult NGrid::regression(const NGrid& other, const bool sample, const uint32_t degree) const {
	RegressionResult result(this->shape[0], this->dimensions == 1 ? 1 : this->shape[1]);

	// check if the dimensions of 'this' and 'other' are valid
	if (this->dimensions > 2) {
		Log::warning("invalid usage of method NGrid::regression(): 'this' must be a 1d or 2d array, returning empty result");
		return result;
	}
	if (other.get_dimensions() > 1 || (other.get_dimensions() == 2 && other.get_shape()[1] != 1)) {
		Log::warning("invalid usage of method NGrid::regression(): 'other' must be a 1d array (or Nx1 2d array), returning empty result");
		return result;
	}

	if (other.get_shape()[0] != this->shape[0]) {
		Log::warning("invalid usage of method NGrid::regression(): 'this' and 'other' must have the same number of rows (", this->shape[0], " != ", other.get_shape()[0], "), returning empty result");
		return result;
	}

	// create X design matrix, start with a 2d column vector of ones
	NGrid X_design({ this->shape[0], 1 });
	X_design.fill(1.0f);

	// make sure 'this' is a 2d matrix (if it is a 1d vector, reshape it to a 2d matrix with shape [n, 1])
	NGrid X_2d;
	if (this->dimensions == 1) {
		X_2d = this->reshape({ this->shape[0], 1 });
	}
	else {
		X_2d = *this; // already a 2d matrix
	}

	uint32_t cols_X = X_2d.get_shape()[1]; // number of columns in X (k)
	uint32_t rows_X = X_2d.get_shape()[0]; // number of rows in X (N)

	// simple or linear or multivariate linear regression: add the X_2d matrix as a column(s) to the design matrix
	if (degree == 1) {
		X_design = X_design.concatenate(X_2d, 1); // concatenate along the second axis (columns)
	}
	// polynomial or multivariate polynomial regression: add polynomial terms up to the specified degree
	else {
		// slice the X_2d matrix into its columns
		std::vector<NGrid> X_columns(cols_X);
		for (uint32_t i = 0; i < cols_X; i++) {
			X_columns[i] = X_2d.subgrid({ 0, i }, { rows_X, 1 }); // extract column i as a 2d column vector
		}

		// This will store tuples of exponents for each term (e.g., {2, 1} for X1^2 * X2^1)
		std::vector<std::vector<uint32_t>> exponent_combinations;
		std::set<std::vector<uint32_t>> unique_combinations_set;

		// Start recursion with an empty (all zeros) exponent vector;
		// the intercept term {0,0,...} is handled by 'X_design' initialization;
		// we only want non-zero total degree terms from this recursive process
		std::vector<uint32_t> initial_exponents(cols_X, 0);

		// The recursive lambda for generating monomial exponent combinations
		std::function<void(std::vector<uint32_t>, uint32_t, uint32_t)> generate_monomial_exponents =
			[&](std::vector<uint32_t> current_exponents, uint32_t current_total_degree_sum, uint32_t start_feature_idx) {

			// Base case: If we've exceeded the max degree, stop this branch
			if (current_total_degree_sum > degree) {
				return;
			}

			// Add the current combination if its total degree is >= 1 (i.e., not the intercept already added)
			// and it's a unique combination.
			if (current_total_degree_sum >= 1) { // Only add terms with at least one non-zero exponent
				unique_combinations_set.insert(current_exponents);
			}

			// Recursive step: For each feature, try to increment its exponent
			// starting from `start_feature_idx` to avoid redundant permutations (e.g., X1*X2 and X2*X1)
			for (uint32_t i = start_feature_idx; i < cols_X; ++i) {
				// Check if adding 1 to this feature's exponent would exceed the max degree
				if (current_total_degree_sum + 1 <= degree) {
					std::vector<uint32_t> next_exponents = current_exponents;
					next_exponents[i]++; // Increment exponent for feature 'i'
					generate_monomial_exponents(next_exponents, current_total_degree_sum + 1, i);
				}
			}
			};

		// Start the generation process
		generate_monomial_exponents(initial_exponents, 0, 0);

		// Convert the set of unique combinations to a vector for ordered processing
		// and apply deglex sort for canonical column order.
		exponent_combinations.assign(unique_combinations_set.begin(), unique_combinations_set.end());

		// Sort to ensure "degree-then-lexicographical" order
		std::sort(exponent_combinations.begin(), exponent_combinations.end(), [](const std::vector<uint32_t>& a, const std::vector<uint32_t>& b) {
			// Calculate total degree for comparison
			uint32_t sum_a = 0; for (uint32_t exp : a) sum_a += exp;
			uint32_t sum_b = 0; for (uint32_t exp : b) sum_b += exp;

			// Primary sort: by total degree
			if (sum_a != sum_b) {
				return sum_a < sum_b;
			}

			// Secondary sort: by lexicographical order of exponent vectors (e.g., [1,1] before [2,0])
			for (size_t i = 0; i < a.size(); ++i) {
				if (a[i] != b[i]) {
					return a[i] < b[i];
				}
			}
			return false; // Vectors are identical
			});


		// --- Now, loop through the sorted exponent combinations and build the columns ---
		for (const auto& exponents : exponent_combinations) {
			// Start with a column of ones. This will be element-wise multiplied by powered features.
			// If a feature has exponent 0, its power term is 1, so it doesn't change the product.
			NGrid current_term_column(rows_X, 1);
			current_term_column.fill(1.0f); // Initialize with ones

			for (uint32_t feature_idx = 0; feature_idx < cols_X; ++feature_idx) {
				uint32_t exponent = exponents[feature_idx];

				if (exponent > 0) {
					// Take the original feature column (e.g., X_columns[0] for X1)
					// Raise it to the required power (element-wise exponentiation)
					NGrid powered_feature_column = X_columns[feature_idx].pow(exponent);

					// Element-wise multiply this powered feature column into our current_term_column
					current_term_column = current_term_column.Hadamard_product(powered_feature_column);
				}
			}
			// Concatenate the newly created column to X_design
			X_design = X_design.concatenate(current_term_column, 1);
		}
	}

	result.num_observations = rows_X;				// N
	result.num_params = X_design.get_shape()[1];	// k+1 (including intercept)
	result.num_predictors = result.num_params - 1;	// k

	// Ensure enough data points for regression
	if (result.num_observations <= result.num_params) { // N <= k+1 means not enough degrees of freedom
		Log::warning("invalid usage of NGrid::regression(): Not enough observations for the given number of predictors (N <= k+1).");
		return result;
	}

	// check for simple linear regression (1 predictor)
	result.is_simple_linear = result.num_predictors == 1 && degree == 1;

	// --- Calculate Coefficients (Beta_hat) ---
	// Formula: beta_hat = (X_T * X)^-1 * X_T * Y
	NGrid X_T = X_design.transpose();
	NGrid XtX = X_T * X_design;
	NGrid XtX_inv = XtX.inverse();
	NGrid XtY = X_T * other;

	*result.coefficients = XtX_inv * XtY; // This will be a (k+1) x 1 NGrid
	result.coefficients_vec = result.coefficients->get_buffer()->read();

	// --- Calculate Predicted Y Values ---
	// Y_hat = X * beta_hat
	*result.y_predict = X_design * *result.coefficients;

	// --- Calculate Core Statistics ---
	result.y_mean = other.mean();
	result.y_variance = other.var(sample);
	result.y_stddev = result.y_variance != 0 ? std::sqrt(result.y_variance) : float_t(NAN);

	if (result.is_simple_linear) {
		result.x_mean = this->mean();
		result.x_variance = this->var(sample);
		result.x_stddev = result.x_variance != 0 ? std::sqrt(result.x_variance) : float_t(NAN);
		result.covariance = (*this - result.x_mean).scalar_product(other - result.y_mean) / (sample ? this->elements - 1 : this->elements);
		result.Pearson_R = result.x_stddev * result.y_stddev != 0 ? result.covariance / (result.x_stddev * result.y_stddev) : float_t(NAN);
	}

	// --- Calculate Sums of Squares ---
	result.SST = (sample ? this->elements - 1 : this->elements) * result.y_variance;

	// --- Calculate Sums of Squares Explained (SSE) and Residuals (SSR) ---
	result.SSE = (*result.y_predict - result.y_mean).pow().sum();
	result.SSR = (other - *result.y_predict).pow().sum();

	// --- Calculate Mean Squared Error (MSE) and Mean Squared Regression (MSR) ---
	result.MSE = result.SSR / (sample ? this->elements - result.num_predictors - 1 : this->elements);
	result.MSR = result.SSE / result.num_predictors;

	// --- Calculate R-squared ---
	result.r_squared = (result.SST != 0) ? (result.SSE / result.SST) : float_t(NAN);

	// --- Calculate Adjusted R-squared ---
	float_t N = static_cast<float_t>(result.num_observations);
	float_t k = static_cast<float_t>(result.num_predictors);
	if (N - k - 1 > 0) { // Avoid division by zero
		result.adjusted_r_squared = 1.0f - (1.0f - result.r_squared) * ((N - 1.0f) / (N - k - 1.0f));
	}
	else {
		result.adjusted_r_squared = float_t(NAN);
	}

	return result;
}

// performs an augmented Dickey-Fuller test
// (=unit root test for stationarity) on the sample array;
// The test returns a p-value, which is used to determine whether or not
// the null hypothesis that the dataset has a unit root
// (=implying that the sample is non-stationary and has a trend) is rejected.
// If the p-value is less than a chosen significance level (usually 0.05),
// then the null hypothesis is rejected and it is concluded that the
// time series dataset does not have a unit root and is stationary.
// The method for differencing is set to first order integer by default,
// but can be changed to other methods via the method's arguments
float_t NGrid::Dickey_Fuller() const {
	if (this->dimensions != 1 || (this->dimensions == 2 && this->shape[1] != 1)) {
		Log::warning("NGrid::Dickey_Fuller() is only valid for 1d vectors, returning NAN");
		return float_t(NAN);
	}
	// correlate a copy of the array with a stationary transformation of itself
	// (i.e. first degree differencing)
	// The first element is omitted in this copy is because the stationary transformation also has one element less
	NGrid copy;
	if (this->dimensions == 1) {
		copy = this->subgrid({ 1 }, { this->shape[0] - 1 });
	}
	else {
		copy = this->subgrid({ 1, 0 }, { this->shape[0] - 1, 1 });
	}
	auto regression_result = copy.regression(this->stationary());
	float R = regression_result.get_Pearson_R();

	// calculate final result
	return R * std::sqrt((float_t)(this->elements - 1) / (1 - std::pow(R, 2)));
}

// takes the source vector and another vector (passed as parameter) and
// performs an Engle-Granger test in order to test the given numeric sample
// for cointegration, i.e. checking series data for a long-term relationship.
// The test was proposed by Clive Granger and Robert Engle in 1987.
// If the returned p-value is less than a chosen significance level (typically 0.05),
// it suggests that the two time series are cointegrated and have a long-term relationship.
// Make sure that both NGrid are 1d and have the same number of elements!
float_t NGrid::Engle_Granger(const NGrid& other) const {
	if (this->dimensions != 1 || (this->dimensions == 2 && this->shape[1] != 1)) {
		Log::warning("NGrid::Engle_Granger() is only valid for 1d vectors, returning NAN");
		return float_t(NAN);
	}
	auto regression_result = this->stationary().regression(other.stationary());
	NGrid residuals = regression_result.get_y_predict() - other;
	return residuals.Dickey_Fuller();
}

// returns a stationary transformation of the vector data,
// e.g. for time series data;
NGrid NGrid::stationary(const uint32_t degree) const {

	// base Case: if degree is 0, return a copy of the original data
	if (degree == 0) {
		return *this;
	}

	// create the result NGrid with one less element
	NGrid differenced_result;
	if (this->dimensions == 1) {
		differenced_result.reshape({ this->shape[0] - 1 });
	}
	else if (this->dimensions == 2 && this->shape[1] == 1) {
		differenced_result.reshape({ this->shape[0] - 1, 1 });
	}
	else {
		// invalid input dimensions
		Log::warning("NGrid::stationary() is only valid for 1d vectors, but 'this' has shape ", this->get_shapestring(), "; result will be empty.");
		return differenced_result;
	}

	// Check if we have enough elements to difference
	if (this->elements < 2) {
		Log::warning("NGrid::stationary(): Not enough elements to perform differencing ('this' has only ", this->elements, " elements), result will be empty.");
		return differenced_result;
	}

	// Recursive Step: Perform one degree of differencing
	static ShaderModule shader(manager->get_device(), STATIONARY_SPIRV_BIN, STATIONARY_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*differenced_result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);

	PushConstants constants(
		differenced_result.get_elements()
	);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d, 1, 1);
	command_buffer->compute(pipeline, differenced_result.get_elements(), 1, 1, true, fence_timeout_nanosec, true); // dispatch with fence and buffer memory barriers
	descriptor_pool->release_set(set);

	// Recursive Call for Higher Degrees
	if (degree > 1) {
		return differenced_result.stationary(degree - 1);
	}
	else { // degree == 1 (this is the final step for degree 1)
		return differenced_result;
	}
}

// returns a stationary transformation of the vector data,
// using first degree logreturn differencing
// e.g. for time series data;
NGrid NGrid::stationary_log(const float_t log_base, const uint32_t degree) const {
	// base Case: if degree is 0, return a copy of the original data
	if (degree == 0) {
		return *this;
	}

	// create the result NGrid with one less element
	NGrid differenced_result;
	if (this->dimensions == 1) {
		differenced_result.reshape({ this->shape[0] - 1 });
	}
	else if (this->dimensions == 2 && this->shape[1] == 1) {
		differenced_result.reshape({ this->shape[0] - 1, 1 });
	}
	else {
		// invalid input dimensions
		Log::warning("NGrid::stationary() is only valid for 1d vectors, but 'this' has shape ", this->get_shapestring(), "; result will be empty.");
		return differenced_result;
	}

	// Check if we have enough elements to difference
	if (this->elements < 2) {
		Log::warning("NGrid::stationary(): Not enough elements to perform differencing ('this' has only ", this->elements, " elements), result will be empty.");
		return differenced_result;
	}

	// Recursive Step: Perform one degree of differencing
	static ShaderModule shader(manager->get_device(), STATIONARY_LOG_SPIRV_BIN, STATIONARY_LOG_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*differenced_result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);

	PushConstants constants(
		differenced_result.get_elements(),
		log_base
	);

	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d, 1, 1);
	command_buffer->compute(pipeline, differenced_result.get_elements(), 1, 1, true, fence_timeout_nanosec, true); // dispatch with fence and buffer memory barriers
	descriptor_pool->release_set(set);

	// Recursive Call for Higher Degrees
	if (degree > 1) {
		return differenced_result.stationary(degree - 1);
	}
	else { // degree == 1 (this is the final step for degree 1)
		return differenced_result;
	}
}

// even-odd sorting algorithm for 1d vectors
NGrid NGrid::sort(const bool ascending) const {
	if (this->dimensions != 1) {
		Log::warning("NGrid::sort() is invalid for multidimensional data structures. The underlying array has ", this->dimensions, ", dimensions");
		return *this;
	}

	NGrid result(this->shape);

	static ShaderModule shader(manager->get_device(), EVEN_ODD_SORT_SPIRV_BIN, EVEN_ODD_SORT_SPIRV_BYTES);

	DescriptorSet set(manager->get_device());
	set.bind_buffer(*data_buffer, DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.bind_buffer(*result.get_buffer(), DescriptorType::STORAGE_BUFFER_DESCRIPTOR);
	set.finalize_layout();

	descriptor_pool->allocate_set(set);
	uint32_t pass = 0;
	PushConstants constants(this->elements, pass, static_cast<uint32_t>(ascending));
	ComputePipeline pipeline(manager->get_device(), shader, constants, set, workgroup_size_1d);

	for (pass = 0; pass < this->elements; pass++) {
		constants.add_values(pass, 4); // (over-)write pass (offset 4 bytes)
		command_buffer->compute(pipeline, this->elements, 1, 1, true, fence_timeout_nanosec);
	}

	descriptor_pool->release_set(set);
	return result;
}

float_t NGrid::covariance(const NGrid& other) const {
	return (*this - this->mean()).scalar_product(other - other.mean()) / this->elements;
}


// +=================================+   
// | Output                          |
// +=================================+

// print the vector or array to the console
// use precision argument for decimal places (use negative number for unformatted full available precision)
void NGrid::print(std::string comment, std::string delimiter, bool with_indices, bool rows_inline, int32_t precision) const {
	uint32_t decimals = std::pow(10, precision);

	if (comment != "") {
		std::cout << comment;
		std::cout << "\n";
	}

	if (this->dimensions == 1) {
		for (uint32_t x = 0; x < this->shape[0]; x++) {
			if (with_indices) {
				std::cout << "[" << x << "]=";
			}
			std::cout << this->get(x);
			if (x != this->shape[0] - 1) {
				if (rows_inline) {
					std::cout << delimiter;
				}
				else {
					std::cout << "\n";
				}
			}
		}
		std::cout << "\n" << std::flush;
	}
	else {
		for (uint32_t x = 0; x < this->shape[0]; x++) {
			for (uint32_t y = 0; y < this->shape[1]; y++) {
				if (this->dimensions == 2 || this->shape[2] == 1) {
					if (with_indices) {
						if (this->dimensions == 1) {
							std::cout << "[" << x << "]=";
						}
						else {
							std::cout << "[" << x << "][" << y << "]=";
						}
					}
					uint32_t index = flat_index({ x, y });
					float value = (precision > 0 ? std::round(this->get(index) * decimals) / decimals : this->get(index));
					value = value == 0.0 ? 0.0f : value; // avoid printing -0.0
					std::cout << value;
					// add delimiter before next column
					if (y != shape[1] - 1) {
						std::cout << delimiter;
					}
				}
				else if (this->dimensions == 3) {
					std::cout << "{";
					for (uint32_t z = 0; z < this->shape[2]; z++) {
						if (with_indices) {
							std::cout << "[" << x << "][" << y << "][" << z << "]=";
						}
						uint32_t index = flat_index({ x, y, z });
						float value = (precision > 0 ? std::round(this->get(index) * decimals) / decimals : this->get(index));
						value = value == 0.0 ? 0.0f : value; // avoid printing -0.0
						std::cout << value;
						if (z != this->shape[2] - 1) {
							std::cout << delimiter;
						}
					}
					std::cout << "}";
					// add space before next column
					if (y != this->shape[1] - 1) {
						std::cout << " ";
					}
				}
				else {
					Log::debug("invalid call of method NGrid::print() for an array of more than 3 dimensions; shape is ", this->get_shapestring());
					return;
				}
			}
			// add line break before next row
			std::cout << "\n";
		}
		// flush to console
		std::cout << std::flush;
	}
}

void NGrid::set_workgroup_size_1d(uint32_t size) {
	workgroup_size_1d = size;

	// make sure the workgroup size is not zero
	if (workgroup_size_1d == 0) {
		Log::warning("NGrid::set_workgroup_size_1d() called with size 0, setting to default value of 32");
		workgroup_size_1d = 32;
	}

	// make sure that the workgroup size is a power of two
	if ((workgroup_size_1d & (workgroup_size_1d - 1)) != 0) {
		Log::warning("NGrid::set_workgroup_size_1d() called with a non-power-of-two size ", workgroup_size_1d, ", setting to next lower power of two");
		workgroup_size_1d = std::bit_floor(workgroup_size_1d); // requires C++20
	}

	// make sure that the workgroup size is not larger than the maximum allowed size
	if (!manager) {
		NGrid x; // create an empty dummy NGrid to make the manager available
	}
	uint32_t max_size = manager->get_device().get_properties().limits.maxComputeWorkGroupSize[0];
	if (workgroup_size_1d > max_size) {
		Log::warning("NGrid::set_workgroup_size_1d() called with size ", workgroup_size_1d, ", which is larger than the maximum allowed size of ", max_size, ", setting to maximum size");
		workgroup_size_1d = max_size;
	}
}

void NGrid::set_workgroup_size_2d(uint32_t size) {
	workgroup_size_2d = size;

	// make sure the workgroup size is not zero
	if (workgroup_size_2d == 0) {
		Log::warning("NGrid::set_workgroup_size_2d() called with size 0, setting to default value of 32");
		workgroup_size_2d = 32;
	}

	// make sure that the workgroup size is a power of two
	if ((workgroup_size_2d & (workgroup_size_2d - 1)) != 0) {
		Log::warning("NGrid::set_workgroup_size_2d() called with a non-power-of-two size ", workgroup_size_2d, ", setting to next lower power of two");
		workgroup_size_2d = std::bit_floor(workgroup_size_2d); // requires C++20
	}

	// make sure that the workgroup size is not larger than the maximum allowed size
	if (!manager) {
		NGrid x; // create an empty dummy NGrid to make the manager available
	}
	uint32_t max_size_x = manager->get_device().get_properties().limits.maxComputeWorkGroupSize[0];
	uint32_t max_size_y = manager->get_device().get_properties().limits.maxComputeWorkGroupSize[1];
	uint32_t max_invocations = manager->get_device().get_properties().limits.maxComputeWorkGroupInvocations;
	uint32_t requested_invocations = workgroup_size_2d * workgroup_size_2d;

	if (workgroup_size_2d > max_size_x || workgroup_size_2d > max_size_y) {
		Log::warning("NGrid::set_workgroup_size_2d() called with size ", workgroup_size_2d, ", which is larger than the maximum allowed size of ", std::min(max_size_x, max_size_y), ", setting to maximum size");
		workgroup_size_2d = std::min(max_size_x, max_size_y);
	}

	if (requested_invocations <= max_invocations) {
		return;
	}
	else {
		while (workgroup_size_2d * workgroup_size_2d > max_invocations) {
			Log::warning("NGrid::set_workgroup_size_2d() called with size ", workgroup_size_2d, ", which will result in ", workgroup_size_2d * workgroup_size_2d, " total invocations;\n",
				"only ", max_invocations, " are allowed -> reducing size by 50% until fit");
			workgroup_size_2d /= 2;
		}
	}
}

// +=================================+   
// | Protected Class Members         |
// +=================================+

// release resources from the shared static descriptor pool
// (the function gets registered by the constructor to be called on program exit)
void NGrid::release_descriptor_pool() {
	if (descriptor_pool != nullptr) {
		delete descriptor_pool;
		descriptor_pool = nullptr;
	}
}

// set the fence timeout in nanoseconds
// (default is 1 second = 1e9 nanoseconds)
void NGrid::set_fence_timeout_nanosec(uint64_t timeout) {
	fence_timeout_nanosec = timeout;
}

// returns a 'flat' equivalent to a multidimensional index
uint32_t NGrid::flat_index(std::initializer_list<uint32_t> multi_index_list) const {
	std::vector<uint32_t> multi_index_vec(multi_index_list);
	return this->flat_index(multi_index_vec);
}

// returns a 'flat' equivalent to a multidimensional index
uint32_t NGrid::flat_index(const std::vector<uint32_t>& multi_index) const {
	// Check if the number of indices provided matches the array's dimensions
	if (multi_index.size() != this->dimensions) {
		Log::warning("Number of indices (", multi_index.size(), ") does not match array dimensions (",
			this->dimensions, "). Returning 0 (potential trunctation).");
		return UINT32_MAX;
	}

	size_t flat_index_calc = 0;
	for (size_t i = 0; i < this->dimensions; ++i) {
		// row-major calculation
		flat_index_calc = flat_index_calc * static_cast<size_t>(this->shape[i]) + static_cast<size_t>(multi_index[i]);
	}

	// Check if the final result fits within the desired return type uint32_t
	if (flat_index_calc > std::numeric_limits<uint32_t>::max()) {
		Log::warning("Calculated flat index (", flat_index_calc, ") exceeds maximum value for uint32_t. Returning 0 (potential truncation).");
		return UINT32_MAX;
	}
	return static_cast<uint32_t>(flat_index_calc);
}

#endif