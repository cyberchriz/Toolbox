// this Vulkan/GLSL compute shader calculates the variance of the
// data buffer elements via parallel reduction and stores the final result in result[0]

#version 450
#define WORKGROUP_SIZE 256

// setup buffers
layout(set = 0, binding = 0) buffer DataBuffer {
	float data[];
};
layout(set = 0, binding = 1) buffer ResultBuffer {
	float result[];
};
layout(set = 0, binding = 2) buffer PartialSumBuffer {
	float partial_sum[];
};
layout(set = 0, binding = 3) buffer Mdev2Buffer {
	float mdev2[];
};
layout(set = 0, binding = 4) buffer SignalBuffer {
	uint signal[];
};

// setup push constants layout
layout(push_constant) uniform PushConstants {
	uint data_elements;
};

// setup local size according to workgroup size
layout(local_size_x = WORKGROUP_SIZE) in;

// main function
void main() {
	uint x = gl_GlobalInvocationID.x;
	uint workgroup_ID = x / WORKGROUP_SIZE;
	uint workgroups = data_elements / WORKGROUP_SIZE + 1;
	signal[workgroup_ID] = 0;
	
	if (x < data_elements) {

		// calculate partial sum within workgroup via parallel reduction
		partial_sum[x] = data[x] / data_elements;
		barrier();
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				partial_sum[x] += partial_sum[x+i];
			}
			barrier();
		}
		signal[workgroup_ID] = 1;

		// add partial sums across workgroups
		float mean = 0;
		for (uint i = 0; i < workgroups; i++) {
			uint loop_count = 0;
			while (signal[i] < 1 && loop_count < 10000) {
				memoryBarrier();
				loop_count++;
			}
			mean += partial_sum[i*WORKGROUP_SIZE];
		}

		// calculate squared mean deviations
		float mdev = data[x] - mean;
		mdev2[x] = (mdev * mdev) / data_elements;
		barrier();

		// calculate partial sum of squared mean deviations (within workgroup) via parallel reduction
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				mdev2[x] += mdev2[x+i];
			}
			barrier();
		}
		signal[workgroup_ID] = 2;

		// calculate final result (add partial mdev2 results across workgroups)
		if (x == 0) {
			float final_result = 0;
			for (uint i = 0; i < workgroups; i++) {
				uint loop_count = 0;
				while (signal[i] < 2 && loop_count < 10000) {
					memoryBarrier();
					loop_count++;
				}
				final_result += mdev2[i * WORKGROUP_SIZE];
			}
			result[0] = final_result;
		}
	}
}