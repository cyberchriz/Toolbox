// this Vulkan/GLSL compute shader calculates the product reduction of the
// data buffer, i.e. the result of multiplication of all individual elements

#version 450
#define WORKGROUP_SIZE 256

// setup buffers
layout(set = 0, binding = 0) buffer DataBuffer {
	float data[];
};
layout(set = 0, binding = 1) buffer ResultBuffer {
	float result[];
};
layout(set = 0, binding = 2) buffer SignalBuffer {
	uint signal[];
};

// setup push constants layout
layout(push_constant) uniform PushConstants {
	uint data_elements;
};

// setup local size according to workgroup size
layout(local_size_x = WORKGROUP_SIZE) in;

// main function
void main() {
	uint x = gl_GlobalInvocationID.x;
	uint workgroup_ID = x / WORKGROUP_SIZE;
	uint workgroups = data_elements / WORKGROUP_SIZE + 1;
	if (gl_LocalInvocationID.x == 0) {
		signal[workgroup_ID] = 0;
	}
	
	if (x < data_elements) {

		// calculate partial product within workgroup via parallel reduction
		result[x] = data[x];
		barrier();
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				result[x] *= result[x+i];
			}
			barrier();
		}
		signal[workgroup_ID] = 1;

		// for final result: multiply partial products across workgroups
		if (x == 0) {
			for (uint i = 1; i < workgroups; i++) {
				uint loop_count = 0;
				while (signal[i] != 1 && loop_count < 10000) {
					memoryBarrier();
					loop_count++;
				}
				result[0] *= result[i*WORKGROUP_SIZE];
			}
		}
	}
}