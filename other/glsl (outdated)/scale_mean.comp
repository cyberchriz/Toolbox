// this Vulkan/GLSL compute shader scales the elements of the array
// according to mean normalization scaling, i.e.
// (x - mean) / (max - min)

#version 450
#define WORKGROUP_SIZE 256

// setup buffers
layout(set = 0, binding = 0) buffer DataBuffer {
	float data[];
};
layout(set = 0, binding = 1) buffer ResultBuffer {
	float result[];
};
layout(set = 0, binding = 2) buffer SignalBuffer {
	uint signal[];
};

// setup push constants layout
layout(push_constant) uniform PushConstants {
	uint data_elements;
};

// setup local size according to workgroup size
layout(local_size_x = WORKGROUP_SIZE) in;

// main function
void main() {
	uint x = gl_GlobalInvocationID.x;
	uint workgroup_ID = x / WORKGROUP_SIZE;
	uint workgroups = data_elements / WORKGROUP_SIZE + 1;
	float minimum;
	float maximum;
	float sum;
	float mean;

	if (gl_LocalInvocationID.x == 0) {
		signal[workgroup_ID] = 0;
	}
	
	if (x < data_elements) {

		// get local minimum within workgroup via parallel reduction
		result[x] = data[x];
		barrier();
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				result[x] = min(result[x], result[x+i]);
			}
			barrier();
		}
		signal[workgroup_ID] = 1;

		// get global minimum across workgroups
		minimum = result[0];
		for (uint i = 1; i < workgroups; i++) {
			uint loop_count = 0;
			while (signal[i] != 1 && loop_count < 10000) {
				memoryBarrier();
				loop_count++;
			}
			minimum = min(minimum, result[i*WORKGROUP_SIZE]);
		}
		barrier();

		// get local maximum within workgroup via parallel reduction
		result[x] = data[x];
		barrier();
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				result[x] = max(result[x], result[x+i]);
			}
			barrier();
		}
		signal[workgroup_ID] = 2;

		// get global maximum across workgroups
		maximum = result[0];
		for (uint i = 1; i < workgroups; i++) {
			uint loop_count = 0;
			while (signal[i] != 2 && loop_count < 10000) {
				memoryBarrier();
				loop_count++;
			}
			maximum = max(maximum, result[i*WORKGROUP_SIZE]);
		}
		barrier();

		// get local sum within workgroup via parallel reduction
		result[x] = data[x];
		barrier();
		for (uint i = 1; i < WORKGROUP_SIZE; i*=2) {
			if (x % (2*i) == 0 && x+i < data_elements) {
				result[x] += result[x+i];
			}
			barrier();
		}
		signal[workgroup_ID] = 3;

		// get global sum across workgroups
		sum = result[0];
		for (uint i = 1; i < workgroups; i++) {
			uint loop_count = 0;
			while (signal[i] != 3 && loop_count < 10000) {
				memoryBarrier();
				loop_count++;
			}
			sum += result[i*WORKGROUP_SIZE];
		}
		barrier();

		// get mean
		mean = sum / data_elements;

		// finish scaling
		result[x] = (data[x] - mean) / (maximum - minimum);
	}
}